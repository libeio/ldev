
## 静态编译捕捉缺陷策略
- 编译器是捕捉缺陷的最好场合。如果可能，要使用编译器进行类型检查。
- 禁止隐式类型转换：用关键字 explicit 声明一个接受 1 个参数的构造函数，并避免使用转换操作符。
- 用不同的类表示不同的数据类型。
- 不要使用枚举创建整型常量，而是用它们创建新类型。

### 隐式转换产生的缺陷
- 假设有两个类 Apple 和 Orange，在 Orange 类中有一个期望接受一个 Orange 类型的参数的函数：
  ```c++
    void DoSomethingWithOrange(const Orange& orange);
  ```
  但是我们可能不小心向它提供了 Apple 类型的对象：
  ```c++
    Apple an_apple(some_inputs);
    DoSomethingWithOrange(an_apple);
  ```
  在下面两种情况下，这样的代码可以通过编译：
    1. 如果 Orange 类具有一个只接受一个 Apple 类型的参数的构造函数。
    2. 如果 Apple 类具有一个可以把它转换为 Orange 的操作符。
  第 1 种情况：
  ```c++
    class Orange {
    public:
        Orange(const Apple& apple);                             // 隐式转换，不可取
        ... omit ...
    };
  ```
  或者
  ```c++
    class Orange {
    public:
        Orange(const Apple& apple, const Banana& p_banana = 0); // 隐式转换，不可取
        ... omit ...
    };
  ```
   第 2 种情况：
   ```c++
    class Apple {
    public:
        operator Orange() const;        // 显式转换，可取
        ... omit ...
    };
  ```
- 对于第 1 种情况，可以使用 explicit 关键字进行声明。对所有接受一个参数的构造函数用关键字 explicit 进行声明，这是值得推荐的做法。
- 一般而言，隐式转换的所有可能性都是不好的思路，因为这无法充分利用编译器检查不同变量类型的功能。
- 安全的示例代码如下：
  ```c++
    #include <iostream>

    class Apple;
    class Orange;

    class Orange
    {
    public:
        Orange() {}
        explicit Orange(const Apple& apple) { std::cout << "In orange" << std::endl; }
    public:
        void DoSomethingWithOrange(const Orange& orange) {}
    };

    class Apple
    {
    public:
        operator Orange () const { std::cout << "In apple" << std::endl; }
    };

    int main() {
        Apple a;
        Orange oa(a);                   // 调用 Orange 中拷贝构造函数
        
        Orange o;
        o.DoSomethingWithOrange(a);     // 调用 Apple 中 Orange 操作符重载

        return 0;
    }
  ```
  除了上面的写法，还有一种更好的方法：
  ```c++
    class Apple {
    public:
        Orange AsOrange() const;
        ... omit ...
    };
  ```
  此时如果想把 Apple 转换为 Orange，需要采用下面的方式：
  ```c++
    Apple apple(some_inputs);
    DoSomethingWithOrange(apple.AsOrange());        // 显式转换
  ```

### 滥用枚举产生的缺陷
- 对于下面两个枚举：
  ```c++
    enum { SUN, MON, TUE, WED, THU, FRI, SAT };
    enum { JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC };
  ```
  这些常量实际上都是整数，对于以下函数：
  ```c++
    void FunctionExpectingDayOfWeek(int day_of_week);
  ```
  传递 MON 和 JAN 并不没有差别，均可以编译。但如果传递 JAN 显然违背了本意。
- 这可以通过使用创建新类型的枚举解决：
  ```c++
    typedef enum { SUN, MON, TUE, WED, THU, FRI, SAT } DayOfWeek;
    typedef enum { JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC} Month;
  ```
  在这种情况下，期望接受一周中的某天为参数的函数可以这样声明：
  ```c++
    void FunctionExpectingDayOfWeek(DayOfWeek day_of_week);
  ```
  这样，如果不慎传入 Month 类型的枚举，将会编译报错。

## 运行时捕捉缺陷策略
- 运行时错误分为两种，分别是程序员错误（缺陷）和在代码绝对正确时所发生的错误。这里只讨论第一种。
- 为了捕捉缺陷而专门编写的一段代码称为安全检查。安全检查失败时，就表示发现了缺陷。
- 当安全检查失败时，就表示发现了缺陷，这时可以做下面两件事情：
    + 尽可能多地提供与这个错误有关的信息。包括发生地点，发生原因以及相关变量值。
    + 采取适当的操作。
    
### 收集错误信息
- 示例如下：
  ```c++
    #define SCPP_ASSERT(condition, msg)                 \
        if (!(condition)) {                             \
            std::ostringstream s;                       \
            s << msg;                                   \
            SCPP_AssertErrorHandler(                    \
                __FILE__, __LINE__, s.str().c_str();    \
        }
  ```
  使用 ostringstream 对象是为了处理类似于下列这种断定：
  ```c++
    SCPP_ASSERT(index < array.size(), "Index " << index << " is out of bounds " << array.size());
  ```
  安全检查会拖慢代码，可以把有些安全检查设置为临时的，只作为测试之用。

### 采取适当操作
- 有两种选择：1. 终止程序; 2. 抛出一个异常
- 终止程序
  ```c++
    void SCPP_AssertErrorHandler(const char* file_name, unsigned line_number, const char* message) {
        // 此处适合插入断点：如有需要，还可以把同样的信息写入到一个日志文件
    #ifdef SCPP_THROW_EXCEPTION_ON_BUG
        throw  scpp::ScppAssertFailedException(file_name, line_number, message);
    #else
        std::cerr << message << " in file " << file_name << " #" << line_number << std::endl << std::flush;
        exit(1);            // 终止程序
    #endif
    }
  ```
- 定义异常类抛出
  ```c++
    namespace scpp {
        class ScppAssertFailedException: public std::exception {
        public:
            ScppAssertFailedException(const char* file_name, unsigned line_number, const char* message);
            virtual const char* what() const throw() {
                return what_.c_str();
            }
            virtual ~ScppAssertFailedException() throw() {}
        private:
            std::string what_;
        };
    }   // namespace scpp
  ```
- 在有些情况下，至少有一部分安全检查必须保留在代码中，即使是在产品模式下。
  
  如假设有一个持续依次处理大量请求的程序在处理其中一个请求时遇到了一个缺陷，即安全检查失败，此时似乎能够让程序继续处理其他请求。在这些情况下，由于一项安全检查的失败而终止程序并不是理想的选择，这个时候应该采取的方法是抛出一个异常，包含详细的错误信息并发送给错误处理函数，并在顶层代码的某个地方捕捉这个异常，把错误信息记录在某个日志文件中。
   
## 索引越界问题
- std::vector 提供了一个 at(index) 函数，它通过抛出一个 out_of_range 异常执行边界检查。但这种安全检查会降低代码的效率，在测试完毕之后，最好使用更快的 [] 操作符在每处对它进行替换。
- 避免"索引越界"错误规则：
    + 不要使用静态或动态分配的数组，可以改用 array 或 vector 模板。
    + 不要使用带方括号的 new 和 delete 操作符，让 vector 模板为多个元素分配内存。
  
## 指针运算问题
- 如果通过索引访问了一个 vector，可以在定义 [] 操作符的时候编写安全检查，而指针做不到这一点。所以要避免指针运算。使用 vector 模板或数组索引。
- 在修改 vector 之前所得到的指向其中某个元素的任何指针、引用或迭代器在 vector 由于增加元素而被修改之后就不应该再使用。

## 拷贝构造、赋值、析构 问题
- 只要有可能，避免编写拷贝构造函数和赋值操作符。
- 在设计类的时候，使析构函数保持为空函数。
- 对于允许构造函数正常结束的对象，析构函数将会被调用，即便这些对象是一个更大对象的一部分，而后者的构造函数并没有正常结束。

## 避免使用C标准库的一些函数
- 对于 strlen()，可以改用 std::string::size()。
- 对于 strcpy()，可以仅仅使用字符串的赋值操作符（即=）来复制字符串。
- 对于 strcat() 或 strncat()，可以改用：
  ```c++
    std::ostringstream buffer;
    buffer << first_string;
    buffer << addition_string;
    std::string result = buffer.str();
  ```
  或者更简短的形式：
  ```c++
    std::string result = first_string;
    result += addition_string;
  ```
