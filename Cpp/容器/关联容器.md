
## 关联容器
- 对于单一关键码的容器，如 map 或 set, 作为结果的迭代器将指向这个惟一的关键码为 k 的元素。
- 对于关键码不惟一的容器，例如 multimap 或 multiset, 结果迭代器将指向关键码为 k 的第一个元素。
- 对于 multimap, 找到第一个匹配可能不如找到所有匹配那么有用，可以使用 equal_range() 查找匹配范围。
  ```c++
    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;
  ```
  程序示例：
  ```c++
    void f(multimap<string, int>& m) {
        typedef multimap<string, int>::iterator MI;
        pair<MI, MI> g = m.equal_range("Gold");
        for (MI p = g.first; p != g.second; ++p) { /***/ }
    }
  ```

## 映射 map
- 下标运算符将关键码作为下标去执行查找，并返回对应的值。如果不存在这个关键码，它就将一个具
  有该关键码和 mapped_type 类型默认值的元素插入这个 map。
  字符串次数统计示例：
  ```c++
    void readitems(map<string, int>& m) {
        string word;
        int val = 0;
        while(cin >> word >> val) m[word] += val;
    }
  ```
- 不能针对 const map 做 operator[]()。如果只是希望确认某个关键码是否存在，那就可以用
  find() 操作，查找不到返回的迭代器将是 map.end()。

## 表操作
  ```c++
  pair<iterator, bool> insert(const value_type& val); // 插入（关键码，值）对
  void erase(iterator pos);                         // 删除被指元素
  size_type erase(const key_type& k);       // 删除关键码为 k 的元素，返回值为被删除个数
  ```
  只有在 map 中不存在具有这个关键码的元素时，插入才能真正执行，返回的 pair 中 second 成员
  表示是否被实际插入。
  
## 多重映射 multimap
- 表操作 insert 与 map 不同：
  ```c++
    iterator insert(const value_type&);     // 返回 iterator, 不是 pair
  ```
  对于 multimap, insert() 操作总是真正的插入，因此，multimap::insert() 将返回一个迭代器，
  而不是像 map 那样的 pair<iterator, bool>。
- multimap 无法像 map 那样支持通过关键码值的下标操作。

## 集合 set
```c++
    pair<iterator,bool> insert (const value_type& val);
```
 
## 多重集合 multiset
```c++
    iterator insert(const value_type&);     // 返回 iterator, 不是 pair
```
