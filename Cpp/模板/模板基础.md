  
  
## 说明
- 模板功能的设计，从根本上说是为了支持静态类型的容器(如表、向量和映射)，以及优雅有效地使用这些程序（通用型程序设计）。这里的一个关键目标是减少宏和强制(显式类型转换)的使用。
  
## 模板参数
- 模板可以有类型参数。可以是常规类型的参数如 int, long, enum, short, char, 还可以是模板参数。
- 常规参数只能是整型参数，且必须是常量表达式，因为模板参数是在编译期(compile-time)对模板进行实例化的，因此特定类型的模板参数传入时不能是运行时类型，而必须是常量表达式。
  ```c++
    template<class T, int i> class Buffer {
        T v[i];
        int sz;
    public:
        Buffer() : sz(i) {}
        // ...
    };
    Buffer<char, 127> cbuf;
    Buffer<Record, 8> rbuf;
  ```
  常量参数常常被用于提供大小或者界限。
- 模板参数示例
  ```c++
    template<class T, int i> ...            // 常量表达式
    template<class T, MyType& mt> ...       // 具有外部连接的对象
    template<class T, func_ptr& fun> ...    // 函数的地址
    template<class T, &X::mem_func> ...     // 非重载的指向成员的指针
  ```
- 特别地，字符串文字量不能被接受为模板参数。
  
## 函数模板参数推断
- 如果不能从模板函数的参数推断出某个模板参数，我们就必须显式地去描述它。做这件事的方式与显式地为模板类提供类型参数一样。
  ```c++
    template<class T> class vector { /***/ };
    template<class T> T* create();
    void f() {
        vector<int> v;
        int* p = create<int>();
    }
  ```
- 显式描述的最常见用途是为模板函数提供返回值类型：
  ```c++
    template<class T, class U> T implicit_cast(U u) { return u; }
    void g(int i) {
        implicit_cast(i);               // 错误：无法推断 T
        implicit_cast<double>(i);       // T 是 double, U 是 int
        implicit_cast<char, double>(i); // T 是 char, U 是 double
        implicit cast<char*, int>(i);   // T 是 char*, U 是 int; 错误：不能将 int 转换为 char*
    }
  ```
  在上面的显式模板参数表中，只有位于最后的类型可以不给出。
- 如果某个模板函数的参数已经通过模板参数推断确定下来，这个参数就不能再同时应用提升、标准转换或者用户定义的转换。
  ```c++
    template<class T> T max(T, T);
    const int s = 7;
    max(s, 7);      // max<int>(int(s), 7)（用平凡转换）
    max('a', 1);    // 错误：有歧义（没有标准转换）
    max(2.7, 4);    // 错误：有歧义（没有标准转换）
  ```
  可以通过显式限定来消解这两个歧义:
  ```c++
    max<int>('a', 1);
    max<double>(2.7, 4);
  ```

## 派生和模板
- 模板和派生都是从已有类型构造新类型的机制，通常都被用于去写利用各种共性的代码。这两种技术的组合是许多有用技术的基础。
- **从一个非模板类派生出一个模板类，这是为一组模板提供一个共用实现的一种方法**：
  ```c++
    template<class T> class Vector<T*> : private Vector<void*> { /***/ };
  ```
- 从一个模板类派生出另一个模板类常常也很有用。基类的一种用途就是作为实现其他类的构造块。如果某个基类的成员依赖于其派生类的模板参数，那么这个基类本身也必须参数化：
  ```c++
    template<class T> class Vector { /***/ };
    template<class T> class Vec : public vector<T> { /***/ };
  ```
- 最常见的情况是基类和派生类具有同样的模板参数，但这并不是一项要求。确实有一些虽然不太常见但也很有趣的技术，依赖于将派生类本身传递给基类：
  ```c++
    template<class C> class Basic_ops { // 容器的基本运算
    public:
        bool operator== (const C&) const;   // 比较所有元素
        bool operator!= (const C&) const;
        // ...
        // 给 C 操作访问权
        const C& derived() const { return static_cast<const C&>(*this); }
    };
    template<class T> class Math_container : public Basic_ops<Math_container<T> > {
    public:
        size_t size() const;
        T& operator[] (size_t);
        const T& operator[] (size_t) const;
        // ...
    };
  ```
- 保持容器与操作分离的另一项替代技术是通过模板参数将它们组合起来，而不用经过派生：
  ```c++
    template<class T, class C> class Mcontainer {
        C elements; 
    public:
        T& operator[] (size_t i) { return elements[i]; }
        friend bool operator==<> (const Mcontainer&, const Mcontainer&);    // 比较元素
        friend bool operator!=<> (const Mcontainer&, const Mcontainer&);
    };
    template<class T> class My_array { /***/ };
    Mcontainer<double, My_array<double> > mc;
  ```

## 模板和虚函数
- 模板和虚函数都可以定义一个界面，为了能有所区分，将虚函数提供的东西称做运行时多态性，而把模板提供的称为编译时多态性或参数式多态性。

## 成员模板
- 一个类或者模板也可以包含本身就是模板的成员。
  ```c++
    template<class T> class Ptr {   // 到 T 的指针
        T* p;
    public:
        Ptr(T*);
        Ptr(const Ptr&);                            // 复制构造函数
        template<class T2> operator Ptr<T2> ();     // 将 Ptr<T> 转换到 Ptr<T2>
        // ...
    };
    template<class T>
        template<class T2>
            Ptr<T>::operator Ptr<T2>() { return Ptr<T2>(p); }
    void f(Ptr<Circle> pc) {
        Ptr<Shape> ps = pc;     // 可以：Circle* 能转换到 Shape*
        Ptr<Circle> pc2 = ps;   // 逻辑上是错误的，但实际操作中可不可行待证
    }
  ```
又如：
  ```c++
    template <class T, class = allocator<T> > class vector {
    public:
        // ...
        template<class In> vector(In first, In last, const A& = A());
        template<class In> void assign(In first, In last);
        template<class In> void insert(iterator pos, In first, In last);
        // ...
    };
  ```

- 成员模板的一个用途是作为一些容器，或者标准库算法的比较函数对象(Compare)使用。
  ```c++
    struct _Iter_less_iter
    {
        template<typename _Iterator1,
                 typename _Iterator2>
            bool operator()(_Iterator1 _it1, _Iterator2 _it2) const { return *__it1 < *__it2; }
    };
  ```

- 注意
    + 成员模板不能是 virtual。
    + 一个模板的模板参数表与其模板成员的模板参数表不能组合在一起。

    
