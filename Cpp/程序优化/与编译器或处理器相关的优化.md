
### 使用 static 声明静态函数

使用 static 声明的函数与普通函数不同， static 函数在内存中只有一份，而普通函数在每个被调用中维持一份备份。


### 使用 inline 优化

略


### 字节对齐

一般来说，在 CPU 访问内存时，如果从特定的地址开始访问一般可以加快速度，比如 32 位(4 字节)的 X86 结构下，若每次访问的变量，其地址都是 4 的倍数，则只需要一次操作，否则可能要访问两次。这就需要各类型数据按照一定的规则在空间上排列，而不是一个接一个地排放，这就是对齐。

编译器为了迎合 CPU 的这一特性，一般在编译时都会对变量的存储方式进行对齐处理。

通常以 4 字节作为默认对齐长度，程序员也可以通过 `#pragma pack (value)` 指定字节对齐长度。


### 数组下标排列及其优化

无论是一维数组或多维数组，其在内存中都是按线性顺序存储的。C 语言是以行优化进行存储的。

根据数组存储方式对数组元素进行合理的顺序访问，可以更有效地利用高速缓存，从而提高运行效率。

非顺序访问:
```c
    for (j = 0; j < 50; j++) {
        for (i = 0; i < 50; i++) {
            a[i][j] = 100 * a[i][j];
        }
    }
```

顺序访问:
```c
    for (i = 0; i < 50; i++) {
        for (j = 0; j < 50; j++) {
            a[i][j] = 100 * a[i][j];
        }
    }
```


### 使用 2 的乘方数

1. 使用 2 的乘方数作为数组大小

对于多维数组，一般来说，编译后程序运行时，要通过乘法运算得到数组元素的位置索引，而大多数编译器是通过位操作运算得到这个索引，如果使用 2 的乘方数作为数组大小，将可以提高计算速度，因为位操作运算比一般的乘法运算快。

例如，对于二维数组 `char a[5][7]`，元素 a25 与起始的线性内存偏移计算为 `2 * 7 + 5`，如果把这个数组变成 `char a[5][8]`，则计算 a25 的位偏移变成了 `2 * 8 + 5`, 这样可以直接进行位操作运算，即 `(2<<3) + 5`。

2. 使用 2 的乘方数作为除数

如果一个在计算式中，除数是一个 2 的乘方数，编译器则可以使用位移计算。

例如， `a / 64` 可以变成 `a << 6` 。


### 编译器对变量寄存器的分配

一般情况下，C 编译器会给程序函数中每个局部变量分配一个寄存器，若局部变量不交叉使用，则可能被分配到同一个寄存器中。若局部变量的个数多于可使用的寄存器的个数，多余的变量将被储存到临时内存中。

可以被分配到寄存器的变量包括: 局部变量，调入子程序时的传递参数，与地址无关的变量。

由于考虑到别名变量可能改写指针地址上的数值，编译器一般不对全局变量、指针变量进行寄存器分配。

变换前:
```c
    int x = 0;
    void calc1()
    {
        for (int i = 0; i < 100; i++) x = x * 2;
    }
```

变换后:
```c
    int x = 0;
    void calc2()
    {
        int y = x;
        for (int i = 0; i < 100; i++) y = y * 2;
        x = y;
    }
```
此示例在变换前，数值计算是通过访问内存来进行的。变换后，计算变量被分配到寄存器中，因而将提高计算速度。

