
## 模板的别名
- 使用 typedef 无法重定义一个模板；
- 场景，固定以 std::string 为 key 的 map
  ```c++
    /** C++98/03 写法 */
    template <typename V>
    struct str_map
    {
        typedef std::map<std::string, V> type;
    };
    // ...
    str_map<int>::type map1;
    // ...
    /** C++11 写法 */
    template <typename V>
    using str_map_t = std::map<std::string, V>;
    // ...
    str_map_t<int> map1;
  ```
  这里使用新的 using 别名语法定义了 std::map 的模板别名叫 str_map_t 。
- 事实上，typedef 可以使用 using 代替。
  ```c++
  /** 在重定义普通类型上，两种使用方法的效果是等价的，唯一不同的是定义的语法。 */
    typedef unsigned int uint_t;
    using uint_t = unsigned int;
  /** 函数类型重命名 */
    typedef void (*func_t)(int, int);
    using func_t = void (*)(int, int);
  ```
- 像上面通过 using 重定义后的效果与 typedef 是等价的。using 重定义后的类型是一个模板，但它既不是类模板也不是函数模板，而是一种新的模板形式: **模板别名**。
- 通过 using 可以轻松定义任意类型的模板表达方式，如下:
  ```c++
    template <typename T>
    using type_t = T;
    // ...
    type_t<int> i;
  ```
  type_t 实例化后的类型和它的模板参数类型等价。这里 type_t<int> 将等价于 int 。
  
## 函数模板的默认模板参数
- 在 C++98/03 中，类模板可以有默认的模板参数，但是却不支持函数的默认模板参数，这一限制在 C++11 中被解除；
- 当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随 `<>` 来实例化；
- 函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在参数表
  最后的限制：
  ```c++
    template <typename R = int, typename U>
    R func(U val)
    {
        return val;
    }
  ```

## 在 C++11 中，不建议特化函数模板
- 如果某种类型不符合函数模板的一般实现方法，通常会重载函数或对这个类型进行特化。在与函数模板中的一般实现有很小差异时，重载是不必要的，这时通过特化函数模板来传递这种差异信息在过去是一个通常的做法。
- 不过在 C++11 中提供了对类型特征(type traits)的支持，这样程序员就完全可以在原函数模板中处理不同类型之间的差异。
