
## 可变参数模板
- 声明可变参数模板时需要在 `typename` 或 `class` 后面带上省略号 "..."。
- 省略号的作用有两个:
    + 声明一个参数包，这个参数包中可以包含 0 到任意个模板参数；
    + 在模板定义的右边，可以将参数包展开成一个一个独立的参数；

## 可变参数模板函数
- 一个可变参数模板函数的定义如下，通过 `sizeof...(args)` 可以打印出模板参数的个数:
  ```c++
    template <typename... T>
    void f(T... args)
    {
        std::cout << sizeof...(args) << std::endl;  // 打印变参的个数
    }
    
    f();            // 0
    f(1, 2);        // 2
    f(1, 2.5, "");  // 3
  ```
- 如果需要用参数包中的参数，则一定要将参数包展开。有两种展开参数包的方法:
    + 一种方法是通过递归的模板函数来将参数包展开；
    + 另外一种是通过逗号表达式和初始化列表方式展开参数包；

## 可变参数模板函数展开
- 递归函数方式展开参数包
  
  通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数，递归终止函数正是用来终止递归的。
  ```c++    
    // 递归终止函数
    void print()
    {
        std::cout << "empty" << std::endl;
    }
    // 展开函数
    template <typename T, typename... Types>
    void print(T head, Types... rest)   // 或者 void print(const T& head,  const Types&... rest)
    {
        std::cout << "parameter " << head << std::endl;
        print(rest...);
    }
    
    // 调用测试
    print(1, 2, 3, 4);
  ```
  输出结果如下:
  ```c++
    parameter 1
    parameter 2
    parameter 3
    parameter 4
    empty
  ```
- 通过 type_traits 来递归展开参数包(了解即可):
  ```c++
    template<std::size_t I = 0, typename Tuple>
    typename std::enable_if<I == std::tuple_size<Tuple>::value>::type printtp(Tuplet)
    {
    }
    template<std::size I = 0, typename Tuple>
    typename std::enable_if<I < std::tuple_size<Tuple>::value>::type printtp(Tuplet)
    {
        std::cout << std::get<I>(t) << std::endl;
        printtp<I + 1>(t);
    }
    template<typename... Args>
    void print(Args... args)
    {
        printtp(std::make_tuple(args...));
    }
  ```
  说明: 先将可变模板参数转换为 tuple, 然后通过递增参数的索引来选择 print 函数，当参数的索引小于总的参数个数时，会不断取出当前索引位置的参数并输出，当参数索引等于总的参数个数
  时终止递归。
- 通过逗号表达式和初始化列表方式展开参数包(了解即可)
  ```c++
    template <class T>
    void printarg(T t)
    {
        std::cout << t << std::endl;
    }
    template <class ...Args>
    void expand_arr(Args... args)
    {
        int arr[] = {(printarg(args), 0)...};
    }

    template <class ...Args>
    void expand_list(Args... args)
    {
        std::initializer_list<int>{ (printarg(args), 0)... };
    }

    // 调用测试
    expand_arr(1, 2, 3, 4);
    expand_list(1, 2, 3, 4);
  ```

## 可变参数模板函数消除重复代码示例
- 打印函数示例
  ```c+++
    template<typename T>
    void Print(T t)
    {
        std::cout << t << std::endl;
    }
    template<typename T, typename... Types>
    void Print(T t, Types... args)
    {
        std::cout << t;
        Print(args...);
    }
  ```
- std::forward 与可变参数模板函数
  
  如下代码:
  ```c++
    template<typename... Types>
    T* Instance(Types... args)
    {
        return new T(args...);
    }
    A* pa = Instance<A>(1);
    B* pb = Instance<B>(1, 2);
  ```
  上述代码中, `Types` 是值拷贝的，存在性能损耗，可以通过完美转发来消除损耗，代码如下:
  ```c++
    template<typename... Types>
    T* Instance(Types&&... args)
    {
        return new T(std::forward<Types>(args)...);
    }
  ```
  
## 实现一个函数包装器

实现关键点: 可变参数模板函数定义，类型拖尾返回，函数绑定。

- 可变参数模板函数定义
  ```c++
    template <class Function, class... Args>
    inline auto FuncWrapper(Function && f, Args && ... args) -> decltype(f(std::forward<Args>(args)...))
    {
        return f(std::forward<Args>(args)...);
    }
  ```
  定义一个函数包装器，包装器名称为 FuncWrapper。模板参数 Function 是一个可调用对象，Args 是可调用对象的参数。

  因为不确定可调用对象的返回值类型，所以采用参数 args 调用 f 后返回值类型后置推导再返回。

- 定义具体的可调用对象

- 通过包装器对可调用对象进行包装使用

[示例程序](5-function_wrapper/func_wrapper.cpp)
