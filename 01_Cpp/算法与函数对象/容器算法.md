
## 非修改性序列算法
+ for_each
+ find/find_if
+ count/count_if
+ equal/mismatch
+ search/search_n/find_end
除了 for_each 之外，都不应该用于调用修改序列中元素的操作。

### for_each
- 最常用的用途就是从序列的元素中提取信息。
  ```c++
    void extract(const list<Club>& lc, list<Person*>& off) // 将 officers 从 lc 放入 off
    {
        for_each(lc.begin(), lc.end(), Extract_officers(off));
    }
    class Extract_officers {
        list<Person*>& lst;
    public:
        explicit Extract_officers(list<Person*>& x) : lst(x) {}
        void operator()(const Club& c) const
        { copy(c.officers.begin(), c.officers.end(), back_iterator(lst)); }
    };
  ```
- 一般来说，带 _if 后缀都说明这个算法使用一个谓词。

### find/find_if
- 算法 find/find_if 返回的类型是迭代器
- 通过 find 算法实现简单的统计
  ```c++
    template<typename C, typename T>
    int count(const C& v, T val) {
        typename C::const_iterator i = find(v.begin(), v.end(), val);
        int n = 0;
        while (i != v.end()) {
            ++n;
            ++i;
            i = find(i, v.end(), val);
        }
        return n;
    }
  ```

### equal/mismatch
```c++
    template<class In, class In2> bool equal(In first, In last, In2 first2);
    template<class In, class In2, class BinPred> bool equal(In first, In last, In2 first2, BinPred p);
    template<class In, class In2> pair<In, In2> mismatch(In first, In last, In2 first2);
    template<class In, class In2, class BinPred> pair<In, In2> mismatch(In first, In last, In2 first2, BinPred p);
```
- equal() 算法简单地告诉我们两个序列中对应各对元素的比较是否都相等；
- mismatch() 则寻找第一对没通过比较的元素，并返回引用它们的迭代器。

## 修改性序列算法
+ copy/copy_backward
+ transform
+ unique/unique_copy
+ replace/replace_if/replace_copy/replace_copy_if
+ remove/remove_if
+ reverse/rotate/random_shuffle
+ swap
+ sort/partial_sort
+ partition/partition_stable
  
### copy/copy_backward
```c++
  template<class In, class Out> Out copy(In first, In last, Out res) {
      while (first != last) *res++ = *first++;
      return res;
  }
  template<class Bi, class Bi2> Bi2 copy_backward(Bi first, Bi last, Bi2 res) {
      while (first != last) *--res == *--last;
      return res;
  }
```
- 必须注意不要写过了目标的末端，保证不会出错的一种方式是采用插入器，使目标可以根据需要增长。
- 当输出序列的开始端位于输入序列里时，我们则应该用 copy_backward()。

### unique/unique_copy
```c++
    template<class For> For unique(For first, For last);
    template<class For, class BinPred> For unique(For first, For last, BinPred p);
    template<class In, class Out> Out unique_copy(For first, For last, Out res);
    template<class In, class Out, class BinPred> Out unique_copy(In first, In last, Out res, BinPred p);
```
- unique() 算法从一个序列里删除重复的元素，而 unique_copy() 则是建立一个无重复的副本。
- unique() 并不像我们设想的那样从输入序列中删除元素，因为它没办法弄清这些迭代器所指的
  容器的类型。实际上，它不过是把不重复的元素移向序列的前部，返回指向这一段无重复子序
  列末端的迭代器。
- 要真正从一个容器里删除重复元素，我们就必须显式地收缩这个容器：
  ```c++
    template<class C> void eliminate_duplicates(C& c) {
        sort(c.begin(), c.end());
        typename C::iterator p = unique(c.begin(), c.end());        // 压紧
        c.erase(p, c.end());                                        // 收缩
    }
  ```

### replace/replace_if/replace_copy/replace_copy_if
```c++
    template<class For, class T> 
    void replace(For first, For last, const T& val, const T& new_val) {
        while (first != last) {
            if (*first == val) *first = new_val;
            ++first;
        }
    }
    template<class For, class Pred, class T>
    void replace_if(For first, For last, Pred p, const T& new_val) {
        while (first != last) {
            if (p(*first)) *first = new_val;
            ++first;
        }
    }
    template<class In, class Out, class T>
    Out replace_copy(In first, In last, Out res, const T& val, const T& new_val) {
        while (first != last) {
            *res++ = (*first == val) ? new_val : *first;
            ++first;
        }
        return res;
    }
    template<class In, class Out, class Pred, class T>
    Out replace_copy_if(In first, In last, Out res, Pred p, const T& new_val) {
        while (first != last) {
            *res++ = p(*first) ? new_val : *first;
            ++first;
        }
        return res;
    }
```

### remove/remove_if
```c++
    template<class For, class T> For remove(For first, For last, const T& val);
    template<class For, class Pred> For remove_if(For first, For last, Pred p);
```
    
### reverse/rotate/random_shuffle
```c++
    template<class Bi> void reverse(Bi first, Bi last);
    template<class For> void rotate(For first, For middle, For last);
    template<class Ran> void random_shuffle(Ran first, Ran last);
    template<class Ran, class Gen> void random_shuffle(Ran first, Ran last, Gen& g);
```
- reverse() 算法反转元素的顺序，使第一个元素变成最后一个，依次类推。
- rotate() 算法将它的序列 `[first, last)` 看作是一个环，它旋转(rotate)这些元素，直至其
  中原来的 middle 元素到达了其 first 原来的位置。
  注意：middle 不是 `[first, last)` 中间的元素，而是 `[first, last)` 之间的某个元素。
- 按默认规定，random_shuffle() 用一个均匀分布的随机数生成器搅乱序列中元素的位置。如果
  需要另一种分布，或者另一个更好的随机数生成器，你也可以给它提供一个。

### sort/partial_sort
- 通过二元谓词实现，默认严格弱排序。
  ```c++
    template<class Ran> void sort(Ran first, Ran last);
    template<class Ran, class Cmp> void sort(Ran first, Ran last, Cmp cmp);
    template<class Ran> void partial_sort(Ran first, Ran middle, Ran last);
    template<class Ran, class Cmp> void partial_sort(Ran first, Ran middle, Ran last, Cmp cmp);
  ```
- sort() 族算法需要随机访问迭代器。也就是说，它们最好是用于 vector 和类似容器。
- partial_sort() 只将位于区间 first 到 middle 的元素排好序。

### partition/partition_stable
- 划分序列就是把所有满足某个谓词的元素放到不满足谓词的元素之前。
  ```c++
    template<class Bi, class Pred> Bi partition(Bi first, Bi last, Pred p);
    template<class Bi, class Pred> Bi stable_partition(Bi first, Bi last, Pred p);
  ```
- 返回值或者指向第一个不满足谓词的元素，或者指向序列结束。

### 谓词与算法结合
- 通过简单的示例说明
  ```c++
    std::map<std::string, int> histogram;
    std::list<std::string> words;
    typedef std::map<std::string, int>::const_iterator MI;
    void record(const std::string& s) {
        histogram[s]++;
    }
    void print(const std::pair<const std::string, int>& r) {
        std::cout << r.first << ' ' << r.second << std::endl;
    }
    bool gt_42(const std::pair<const std::string, int>& r) {
        return r.second > 42;
    }
    for_each(words.begin(), words.end(), record);               // 统计 words 中各单词出现频率，记入 histogram
    for_each(histogram.begin(), histogram.end(), print);        // 打印 histogram 第个成员
    MI i = find_if(histogram.begin(), histogram.end(), gt_42);  // 找到 histogram 中第一个出现次数大于 42 的单词
  ```
- 上述的 record, print, gt_42 因其具有控制算法的作用，而被称为谓词函数。
- record, print, gt_42 可以使用 lambda 表达式代替。对于一些"一句话"函数，最好使
  用 lambda 表达式。
- 注意，缺省时 std::map 按 < 排序。对于 gt_42 谓词函数，因为其使用 return 返回，
  所以其返回第一个出现次数大于 42 的单词。
- 从此示例中可以了解到，谓词函数如何返回应该与调用函数的逻辑保持一致辞。在这里
  find_if 的返回值是第一次出现符合要求的迭代器，返回使用 return 返回一个 bool 值。
  
### 算法中使用成员函数
- 对一个 `list<Shape>` 里的每个元素调用成员函数 Shape::draw() 的实现。
  ```c++
    list<Shape*> sh;
    void draw(Shape* p) {
        p->draw();
    }
    for_each(sh.begin(), sh.end(), draw);
  ```
- 上述方法需要程序员额外定义一个 draw 函数。不过 STL 已经通过 mem_fun() 解决了这种
  麻烦的写法:
  ```c++
    for_each(sh.begin(), sh.end(), mem_fun(&Shape::draw));
  ```
- 标准模板库 mem_fun() 以一个到类的成员函数的指针为参数，使它可以调用该方法。这里
  mem_fun(&Shape::draw) 的结果就是以 `Shape*` 为参数，返回 Shape::draw() 的返回结果。
