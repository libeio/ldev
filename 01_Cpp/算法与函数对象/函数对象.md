
## 函数对象
- 示例
  ```c++
    bool less_than_7(int v) {
        return v < 7;
    }
    void f(list<int>& c) {
        list<int>::iterator p = find_if(c.begin(), c.end(), less_than_7);
        // ...
    }
  ```
- 使用函数对象
  ```c++
    template<class T> class Sum {
        T res;
    public:
        Sum(T i = 0) : res(i) {}                // 初始化
        void operator() (T x) { res += x; }     // 累加
        T result() const { return res; }        // 返回和数
    };
    void f(list<double>& ld) {
        Sum<double> s;
        s = for_each(ld.begin(), ld.end(), s);  // 调用 s(*iterator)
        cout << "the sum is " << s.result() << endl;
    }
  ```
- for_each() 实际并不假设其第三个参数就是函数，它只假设第三个参数是某种可以用合适的参数去调
  用的东西。
  像 Sum 这样，如果一个类的对象具有应用运算符，就称它为一个拟函数对象、函子，或者简单地称为
  函数对象。

## 函数对象的基类
c++ 提供了两个基类供用户从 unary_function 和 binary_function 派生出自己的类，构造函数对象。
- 一元谓词基类
  ```c++
    template<class Arg, class Res> struct unary_function {
        typedef Arg argument_type;
        typedef Res result_type;
    };
  ```
- 二元谓词基类
  ```c++
    template<class Arg, class Arg2, class Res> struct binary_function {
        typedef Arg first_argument_type;
        typedef Arg2 seoncd_argument_type;
        typedef Res result_type;
    };
  ```

## 谓词
- 谓词就是返回 bool 的函数对象（或函数）。
<functional> 中定义的一些谓词：
  ```c++
    template<class T> struct logical_not : public unary_function<T, bool> {
        bool operator() (const T& x) const { return !x; }
    };
    template<class T> struct less : public binary_function<T, T, bool> {
        bool operator() (const T& x, const T& y) const { return x < y; }
    };
    void f(vector<int>& vi, list<int>& li) {
        typedef list<int>::iterator LI;
        typedef vector<int>::iterator VI;
        pair<VI, LI> pl = mismatch(vi.begin(), vi.end(), li.begin(), less<int>());
        // ...
    }
  ```
  mismatch 中最后一个参数，不是传入具体的实例类，而是通过类进行参数化定义。就相当于：
  ```c++
      less<int> L;      // 调用 less 类的默认构造函数 less() {} 进行构造
      mismatch(vi.begin, vi.end(), li.begin(), L);  // 对每个元素调用 L.operator()(x, y)
  ```
- 自定义谓词
  ```c++
    struct Club {
        string name;
        list<Person*> officers;
        // ...
        Club(const string& n);
    };
    class Club_eq : public unary_function<Club, bool> {     // 一元谓词函数类
        string s;
    public:
        explicit Club_eq(const string& ss) : s(ss) {}
        bool operator()(const Club& c) const { return c.name == s; }
    };
    void f(list<Club>& lc) {
        typedef list<Club>::iterator LCI;
        LCI p = find_if(lc.begin(), lc_end(), Club_eq("Dining Philosophers"));      // 传入一元谓词函数对象实例
        // ...
    }
    // 通过自定义谓词，将 find_if 的用法扩展，很强！
  ```

## 约束器、适配器、否定器
- 约束器：通过将一个参数约束到某个值，使我们可以将两个参数的函数对象当做一个参数的函数对象使用；
- 成员函数适配器：使成员函数可以被用做算法的参数；
- 函数指针适配器：使函数指针可以被作为算法的参数；
- 否定器：使我们能描述某个谓词的否定。
这些函数对象统称为适配器。对这些适配器中的每一个都提供了一个协助函数，它以一个函数对象为参数，返回另一个合适的函数对象。

## 约束器
  bind2nd(y)     binder2nd     以 y 作为第二个参数调用二元函数，即将二元谓词函数对象约束为一元谓词函数对象
  bind1st(x)     binder1st     以 x 作为第一个参数调用二元函数
- 以 bind2nd 为例看约束器类：
  ```c++
    template<class BinOp>       // 模板参数，二元谓词函数对象
    class binder2nd 
    : public unary_function<typename BinOp::first_argument_type, typename BinOp::result_type> // 约束为一元，自然要继承于一元
    {
    protected:
        BinOp op;
        typename BinOp::second_argument_type arg2;      // 将第二个参数作为一个成员。这样在函数对象类实例化后，该值就是一个“常量”了
    public:
        binder2nd(const BinOp& x, const typename BinOp::second_argument_type& v) : op(x), arg2(v) {} 
        result_type operator() (const argument_type& x) const { return op(x, arg2); }   // 协助函数。可以看到，本质上还是在 BinOp 中进行处理
    };
  ```
- 约束器模板函数：因为约束器类在构造时要用到模板参数，为了美观（IMHO），隐藏起来
  ```c++
    template<class BinOp, class T> binder2nd<BinOp> bind2nd(const BinOp& op, const T& v) {
        return binder2nd<BinOp>(op, v);         // 实际上是对约束器类的简单包装
    }
  ```
  用法很简单，只要对 bind2nd 函数传入一个原本的二元谓词函数及约束值就可以了。
  ```c++
    void f(list<int>& c) {
        list<int>::const_iterator p = find_if(c.begin(), c.end(), bind2nd(less<int>(), 7));
        // ...
    }
  ```
  
## 成员函数适配器
  mem_fun
  mem_fun_ref
- 成员函数只能由类或对象去调用，无法从外部直接进行调用。如
  ```c++
    list<Shape*> c;
    for_each(c.begin(), c.end(), &Shape::draw);
  ```
  是不可行的。原因是 Shape::draw 由元素对象从外部直接调用，而不是作为成员函数由元素对象调用。
- 成员函数地址是客观存在的，只有在对象构造成功时，它才可以被调用。
  ```c++
    template<class R, class T> class mem_fun_t : public unary_function<T* R> {
        R (T::*pmf)();      // 成员函数指针类型
    public:
        explicit mem_fun_t(R (T::*p)()) : pmf(p) {}     // 通过对象成员函数指针进行构造
        R operator() (R (T* p)) const { (p->*pmf)(); }  // 相当于给成员函数在外层附加了一层可供元素对象直接调用的外部函数
    };
    template<class R, class T> mem_fun_t<R, T> mem_fun(R (T::*f)()) {
        return mem_fun_t<R, T>(f);
    }
    void draw_all(list<Shape*>& lsp) {
        for_each(lsp.begin(), lsp.end(), mem_fun(&Shape::draw));
    }
  ```
- mem_fun_ref 的用法：
  ```c++
    void f(list<string>& ls) {
        typedef list<string>::iterator LSI
        LSI p = find_if(ls.begin(), ls.end(), mem_fun_ref(&string::empty));
    }
  ```
- 可以通过绑定去处理使用一个参数的成员函数。
  ```c++
    void rotate_all(list<Shape*>& ls, int angle) {
        for_each(ls.begin(), ls.end(), bind2nd(mem_fun(&Shape::rotate), angle));
    }
  ```
- 标准库不需要去处理多于一个参数的成员函数，因为没有一个标准库算法以多于两个参数的函数作为操作数。
  
## 函数指针适配器
  略
  
## 否定器
  略