
## 记录C++标准算法库一些函数的用法
- 主要对一些带谓词的函数进行用法示例，每个函数的使用方法尽量通过三种方式
  (函数对象(function object)、函数指针(function pointer)和 lambda 表达式)
  进行说明；
- 每个用法示例会尽量贴合应用场景，所以一些函数示例可能不会举例谓词的使用；
- 对一些常用到的不带谓词的函数，可能也会给出示例；
- 可能也会涉及 C++11 的东西；
- 本记录仅仅是自己的理解；
- 不定期添加；
- 具体选择哪种算法取决于应用场景。std::transform 和 std::copy_if 均可以从一个
  序列中找出具有相同某条件的元素集合，但显然 std::copy_if 更贴合应用场景。如
  果要求将某条件的元素集合改为另外一种状态，那么 std::transform 更适合一些。

## 谓词
- 定义
    + 就是返回 bool 的函数对象(或者函数)。
    + 所以谓词包括两类，函数对象和函数。
    + 函数对象可以自定义实现，也可以通过 std::bind 实现；
    + 函数一般指函数指针；
    + lambda 表达式是一种匿名函数对象。
- 分类
    + 分为一元谓词(UnaryPredicate)和二元谓词(BinaryPredicate)，根据自己
      的业务场景使用不同的谓词。
    + 一元谓词常常用来进行判断，二元谓词常常用作比较，但未必都是这种套路。
- 注意: 谓词函数必须是真实存在的，理解如下:
    + 必须保证函数对象是真实存在的。都对象了，当然已经存在了。
    + 必须保证函数指针是真实存在的。指针有地址，当然也是真实存在的。
    + 所以为了保证谓词真实存在，通过模板函数实现谓词时，必须要进行对象化。
      ```c++
        template<typename T> struct less {
            bool operator()(const T& x, const T& y) const { return x < y; }
        };
        
        mismatch(v.begin(), v.end(), less<int>);    // error 谓词不能是一个类型
        mismatch(v.begin(), v.end(), less<int>());  // ok 模板函数类型对象化
      ```
- 注意: 应该保持谓词函数的纯洁性。不要让谓词保存或访问对其 operator() 结果
  有影响的状态，包括成员状态和全局状态。应该使 operator() 成为谓词的 const
  成员函数。

## 函数对象、函数指针和 lambda 表达式的使用说明
- 函数对象更灵活，使用起来更方便，其功能囊括了函数指针和 lambda 表达式，即
  后两者能实现的功能通过函数对象均能实现，但反之不然。
- 函数指针和 lambda 表达式类同，但后者可以对当前环境进行值捕获或引用捕获，
  从这方面看 lambda 表达式比函数对象更方便，比函数指针更强大。
- 当然函数指针也可以通过与 std::bind 一起实现约束器以期达到与函数对象相同
  的功能。
- 通过函数对象、函数指针和 lambda 表达式实现谓词时，应该保证程序块的体积精
  简(俗称的"一句话函数")，这是这样设计它们的初衷。
- 综上可以看出，对于实现谓词，更建议使用的是函数对象和 lambda 表达式。
  而函数指针通常只适用于定值操作。如果你想对函数指针应用模板扩充适用范围的
  话...用谓词就是为了方便，那样的话是不是变得不方便了呢。

## 当前会用到 std::bind 的哪些功能?
- 通过 std::bind 可以返回一个可调用函数对象供其他函数使用，在当前用例集中，
  这个函数对象也可以作为谓词。
- 当前用例集中可能用到的 std::bind 的功能:
    + 与函数指针一起实现可调用函数对象；
    + 与函数指针一起实现约束器(本质上还是函数对象)，示例见 replace_if ；
    + 与模板函数类型一起实现可调用函数对象；
- 说明: 函数对象多是为调用函数而服务的，所以也叫做可调用函数对象。

## 分组对照
- 对元素读操作
    + copy
    + copy_if
    + transform
    + remove_copy_if
    + replace_copy_if
    + unique_copy
- 对元素写操作
    + fill
    + remove_if
    + replace_if
    + unique
- 可读可写操作
    + for_each
- 判断
    + all_of
    + any_of
    + none_of
- 比较
    + equal
    + mismatch
- 计数
    + count_if
- 查找
    + equal_range
    + lower_bound
    + upper_bound
    + find_if
    + search
    + find_end
    + find_first_of
    + adjacent_find
- 排序
    + sort

## 编译说明
- 编译工具
    + cmake
- 已测试环境
    + Debian 9  pass
    + RHEL 7.5  pass

## 迭代忘记了吗?
- 迭代器操作

|  类型  | 输出/Out | 输出/In | 前向/For | 双向/Bi |   随机访问/Ran   |
|--------|----------|---------|----------|---------|------------------|
| 读     |          | =*p     | =*p      | =*p     | =*p              |
| 访问   |          | ->      | ->       | ->      | -> []            |
| 写     | *p=      |         | *p=      | *p=     | *p=              |
| 迭代   | ++       | ++      | ++       | ++ --   | ++ -- + - += -=  |
| 比较   |          | == !=   | == !=    | == !=   | == != < > <= >=  |

- 迭代器类别
```shell
    Input  <---+
               + <--- Forward <--- Bidirectional <--- Random access
    Output <---+
```

## 标准算法库使用注意
- 查找无序范围，应使用 find/find_if 或者 count/count_if 。查找有序范围，应使用
  lower_bound、upper_bound 及 equal_range 。
- 如果所查找的是一个关联容器，那么应该使用同名的成员函数，不要使用非成员算法。
  成员函数版本的效率通常更高，比如 count 的成员函数版本的执行时间是对数级的(因
  此无需像 count 的非成员函数版本那样，先调用 equal_range, 再调用 distance)。