

## 说明
- 在各种标准序列里，只有 vector 和 deque 支持下标。这样做的原因是不希望通过提供从根本上
  低效的操作使用户感到困惑。
- assign 族函数
  需要这些函数，是因为 = 右边只能是一个运算对象，如果要采用一个默认参数值，或者需要提供
  一个范围中的一些值时，就需要用 assign() 了。
- push_back() 将隐式地导致 vector 的 size() 的增长，所以 vector 不会上溢。
- vector 迭代器支持算术操作和自操作，如 vec.begin() + 7。
  list 迭代器支持自操作，但不支持算术操作，可以通过 advance（） 实现类似功能。
- 当复制元素的方式不正确时，可以换一种方式，把指向对象的指针放入容器，而不是放这些对象本身。

## 向量 vector
- 关于 std::vector 的越界问题，虽然可以使用 at 避免，但因其增加了异常处理机制而使得其效率相
  比 [] 大打折扣。

## 列表 list
- list 提供的是双向迭代器，而不是随机访问迭代器。
- list 给出了 vector 所提供的几乎所有成员类型和操作，例外的就是下标、capacity()和 reserve()。
- 虽然 list 也重载了 [] 操作符，但因为其元素并不是连续存储的，所以其效率未必见得比使用 for 迭
  代更高一些。
- 粘接、排序和归并
  ```c++
    template<class T, class A = allocator<T> > class list {
    public:
        // ...
        void splice(iterator pos, list& x);             // 将 x 的所有元素移到本表的 pos 之前，且不作复制。操作后 x 为空表
        void splice(iterator pos, list& x, iterator p); // 将 x 中的 *p 移到本表的 pos 之前，且不作复制。操作后 *p 不再是 x 的元素
        void splice(iterator pos, list& x, iterator first, iterator last);
        void merge(list&);      // 归并排序的表
        template<class Cmp> void merge(list&, Cmp);     // Cmp 为谓词函数
        void sort();
        template <class Cmp> void sort(Cmp);
        // ...
    };
  ```
  merge() 组合起两个排好序的表，方式是将一个 list 的元素都取出来，将它们都放入另一个表，且
  维持正确的顺序。对于 x.merge(y)，操作完成后，y 将变成空表。
- 其他操作
  ```c++
    template<class T, class A = allocator<T> > class list {
    public:
        // ...
        void remove(const T& val);
        template <class Pred> void remove_if(Pred p);   // Pred 是谓词函数
        void unique();                                  // 根据 == 删除重复元素
        template<class BinPred> void unique(BinPred b); // 根据 b 删除重复元素
        void reverse();                                 // 链表反转
        // ...
    };
  ```
  一般使用 unique() 要先使用 sort() 进行操作，因为前者只能删除连续出现的重复元素。

## 双端队列 deque
- 对其两端的操作效率类似于 list, 而其下标操作具有接近 vector 的效率。
- 注意: "在中间"插入和删除元素具有与 vector 一样低效率，而不是类似 list 的效率。

## 容器适配器 stack queue priority_queue
- 容器适配器所提供的是原来容器的一个受限的界面。特别是适配器不提供迭代器，提供它们的意图就
  是为了只经由它们的专用界面使用。

## 堆栈 stack
```c++
    template <class T, class C = deque<T> > 
    class std::stack
    {
    protected:
        C c;
    public:
        typedef typename C::value_type value_type;
        typedef typename C::size_type size_type;
        typedef C container_type;
        
        explicit stack(const C& a = C()) : c(a) {}
        
        bool empty() const { return c.empty(); }
        size_type size() const { return c.size(); }
        
        value_type& top() { return c.back(); }
        const value_type& top() const { return c.back(); }
        
        void push(const value_type& x) { c.push_back(x); }
        void pop() { c.pop_back(); }
    };
```
堆栈也可以采用任何提供了 back()、push_back() 和 pop_back() 的序列作为保存自己元素的容器。

## 队列 queue
```c++
    template <class T, class C = deque<T> >
    class std::queue
    {
    protected:
        C c;
    public:
        typedef typename C::value_type value_type;
        typedef typename C::size_type size_type;
        typedef C container_type;
        
        explicit queue(const C& a = C()) : c(a) {}
        
        bool empty() const { return c.empty(); }
        size_type size() const { return c.size(); }
        
        value_type& front() { return c.front(); }
        const value_type& front() const { return c.front(); }
        
        value_type& back() { return c.back(); }
        const value_type& back() const { return c.back(); }
        
        void push(const value_type& x) { c.push_back(x); }
        void pop() { c.pop_front(); }
    };
```
不同线程中请求程序和服务程序的消息同步处理：
```
    void server(queue<Message>& q, Lock& lck) {
        while (! q.empty()) {
            Message m;
            {
                LockPtr h(lck);         // 只在提取消息时掌握锁
                if (q.empty()) return;  // 其他程序取走了消息
                m = q.front();
                q.pop();
            }
            m.service();                // 调用为请求提供服务的函数
        }
    }
```

## 优先队列 priority_queue
略

