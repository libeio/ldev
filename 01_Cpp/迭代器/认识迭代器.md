
### 迭代器定义

迭代器是一个类模板，其定义如下:

```c++
    template<class Category,                // iterator_traits::iterator_category
             class T,                       // iterator_traits::value_type
             class Distance = ptrdiff_t,    // iterator_traits::difference_type
             class Pointer = T*,            // iterator_traits::pointer
             class Reference = T&           // iterator_traits::reference 
             > class iterator
    {
        typedef T           value_type;
        typedef Distance    difference_type;
        typedef Pointer     pointer;
        typedef Reference   reference;
        typedef Category    iterator_category;
    };
```

迭代器类模板约定了 5 个模板参数，这些称为迭代器的类型特征。其含义如下:
```
    difference_type     标识迭代器间距离的有符号整数类型
    value_type          迭代器解引用后的类型。对于输出迭代器，为 void
    pointer             指向被迭代类型(value_type)的指针类型
    reference           被迭代类型(value_type)的引用类型
    iterator_category   迭代器类型标签类
```

difference_type, pointer, reference 都有默认模板参数，我们在实现自己的迭代器时，只需要指定前两个参数即可。

[简单实现一个随机迭代器](01_iterator/my_iterator.cpp)

不过，实际过程中很少用到 iterator 类模板，更多情况使用的是由其派生或内聚其的迭代器模板类，如 istream_iterator, ostream_iterator, reverse_iterator, insert_iterator, move_iterator 等。


### 迭代器类型特征模板类

C++ 提供了迭代器类型特征模板类 std::iterator_traits。它是一个相对独立的类模板，模板参数为迭代器，用于获取迭代器的特性。没错，就是迭代器类模板定义时的 5 个模板参数。

声明如下:
```c++
    template <class Iterator> class iterator_traits;
    template <class T> class iterator_traits<T*>;
    template <class T> class iterator_traits<const T*>;
```

标准库算法限定传入的迭代器应具有某种特性，特征类使迭代器具有该种特性(不如说是获取，之后将结果交给算法抉择更好些)，以满足相关算法。


### 补充: 迭代器与指针的区别

迭代器与指针的区别，个人认为主要体现在对资源的深浅拷贝上，进一步可以引申为对资源的从属关系上。

定义了一块资源后，然后用指针指向它，进行标识。指针为空了，这个资源也就找不到了。所以指针是否为空关系着资源是否存在，即指针就是资源。所以对指针的拷贝应理解为对资源的拷贝，即深拷贝。

先有资源，然后才可以定义对这块资源的迭代器，即就算迭代器消失了，资源依旧存在，所以对迭代器的拷贝应理解为浅拷贝。

具体表现在指针和迭代器对赋值拷贝构造函数的不同实现上。

在 C++ 中，一般原则是对于容器的操作使用迭代器，对于资源或对象的操作使用指针。
