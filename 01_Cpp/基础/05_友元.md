
## 友元
- 原则上，类的私有和保护成员不能被同类对象从外部进行访问。然而，这个原则可以通过"友元"打破。
- 友元通过关键字 `friend` 声明，一般分为友元函数和友元类。

## 友元函数
- 通过 friend 在一个类中声明一个非成员函数，该非成员函数就可以访问这个类的私有和保护成员。
- 示例
  ```c++
    #include <iostream>
    
    class Rectangle
    {
        int width, height;
    public:
        Rectangle() {}
        Rectangle(int x, int y) : width(x), height(y) {}
        int area() { return width * height; }
        friend Rectangle duplicate(const Rectangle&);
    };
    
    Rectangle duplicate(const Rectangle& param)
    {
        Rectangle res;
        res.width = param.width * 2;
        res.height = param.height * 2;
        return res;
    }
    
    int main()
    {
        Rectangle foo;
        Rectangle bar(2, 3);
        foo = duplicate(bar);
        std::cout << foo.area() << std::endl;
        
        return 0;
    }
  ```
- 友元函数并不是一个类的成员函数，只是在该函数内部可以类外访问该类私有和保护成员而已。
- 使用友元函数的典型场景是两个不同类之间互相需要访问对方私有或保护成员的情形。

## 友元类
- 友元类的声明方式和友元函数相似，友元类的成员可以访问其他类中的私有和保护成员。
- 示例
  ```c++
    #include <iostream>
    
    class Square;
    
    class Rectangle
    {
        int width, height;
    public:
        int area() { return width * height; }
        void convert(Square a);
    };
    
    class Square
    {
        friend class Rectangle;
    private:
        int side;
    public:
        Square(int a) : side(a) {}
    };
    
    void Rectangle::convert(Square a)
    {
        width = a.side;
        height = a.side;
    }
    
    int main()
    {
        Rectangle rect;
        Square sqr(4);
        rect.convert(sqr);
        std::cout << rect.area() << std::endl;
        
        return 0;
    }
  ```
- 友元类的关系不具有交换性和传递性。
- 友元类的最常见使用场景
    + 仅 B 类需要访问 A 类成员， A 类没有必要对其他类型 public 化，这时就可以将 B 类声明为 A 类的友元类。