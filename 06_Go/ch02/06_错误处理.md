
### error 接口

Go 语言引入了一个关于错误处理的标准模式，即 `error` 接口，该接口的定义如下:
```go
  type error interface {
      Error() string
  }
```

对于大多数函数，如果要返回错误，大致上都可以定义为如下模式，将 error 作为多种返回值中的最后一个，但这并非强制要求:
```go
  func Foo(param int)(n int, err Error) {
      // ...
  }
```

调用时的代码建议按如下方式处理错误情况:
```go
  n, err := Foo(0)
  
  if err != nil {
      // 错误处理
  } else {
      // 使用返回值n
  }
```


### defer

Go 语言通过 `defer` 关键字处理资源释放问题。

如下:
```go
    func CopyFile(dst, src string) (w int64, err error) {
        srcFile, err := os.Open(src)
        if err != nil {
            return
        }

        defer srcFile.Close()

        dstFile, err := os.Create(dstName)
        if err != nil {
            return
        }

        defer dstFile.Close()

        return io.Copy(dstFile, srcFile)
    }
```
上述代码中，即使 CopyFile 函数抛出异常，仍然可以保证 dstFile 和 srcFile 会被正常关闭。

defer 语句的调用遵照先进后出原则，即最后一个 defer 语句将最先被执行。

如果需要处理的东西太多，也可以通过 defer 构造匿名函数:
```go
    defer func() {
        // more clear
    }
```


### panic() 和 recover()

略
