
Go 语言的接口并不是其他语言中所提供的接口概念。

Java, C++ 中的接口具有"侵入式"特性，即先定义上层抽象接口，之后下层必须实现对应于该接口的方法，否则就无法实例化为对象。

在 Go 语言中，接口的定义和类的实现是没有必然关联的。如果一个类实现了接口要求的所有函数，我们就说这个类实现了该接口，该接口就可以调用这个类中的方法。

< 理解Go interface含义的关键是跳出C++等语言中关于接口的定义与实现 >

以下定义了一个 File 类及对应的一些成员方法:
```go
    type File struct {
        // ...
    }

    func (f * File) Read(buf []byte) (n int, err error)
    func (f * File) Write(buf []byte) (n int, err error)
    func (f * File) Seek(off int64, whence int) (pos int64, err error)
    func (f * File) Close() error
```

定义如下接口:
```go
    type IFile interface {
        Read(buf []byte) (n int, err error)
        Write(buf []byte) (n int, err error)
        Seek(off int64, whence int) (pos int64, err error)
        Close() error
    }

    type IReader interface {
        Read(buf []byte) (n int, err error)
    }

    type IWriter interface {
        Write(buf []byte) (n int, err error)
    }

    type ICloser interface {
        Close() error
    }
```
无论是接口 IFile, IReader, IWriter 或者 ICloser 都可以称为是 File 类的接口，尽管 File 类并没有从这些接口继承，甚至不知道这些接口的存在。
```go
    var file1 IFile = new(File)
    var file2 IReader = new(File)
    var file3 IWriter = new(File)
    var file4 ICloser = new(File)
```


### 接口赋值

在 Go 语言中，只要两个接口拥有相同的方法列表(无关次序)，那么它们就是等同的，可以相互赋值。

```go
    package one
    
    type ReadWriter interface {
        Read(buf []byte) (n int, err error)
        Write(buf []byte) (n int, err error)
    }

    package two

    type IStream interface {
        Write(buf []byte) (n int, err error)
        Read(buf []byte) (n int, err error)
    }
```
以上两个接口虽然位于不同的包内，且接口次序也不同，但这两个接口本质上并无区别。以下代码均可编译通过:
```go
    var file1 two.IStream = new(File)
    var file2 one.ReadWriter = file1
    var file3 two.IStream = file2
```

接口赋值并不要求两个接口必须等价。如果接口 A 的方法列表是接口 B 的方法列表的子集，那么接口 B 可以赋值给接口 A，但反过来并不成立。


### 接口查询

在 Go 语言中，确定对象是否满足某个接口，可以通过接口查询来完成。
```go
    var file1 Writer = ...
    if file4, ok := file1.(two.IStream); ok {
        // use file5
    }
```
这个 if 语句检查 file1 接口指向的对象实例是否实现了 two.IStream 接口，如果实现了，则执行特定的代码。

[接口查询示例](t/03_interface_query.go)

### 类型查询

在 Go 语言中，还可以直接询问接口指向的对象实例的类型，如:
```go
    var v1 interface{} = ...
    switch v := v1.(type) {
        case int:       // 现在 v 的类型是 int
        case string:    // 现在 v 的类型是 string
        ...
    }
```
类型查询并不常用，更多地配合接口查询使用。

可以参考上面的接口查询示例。


### Any 类型

由于 Go 语言中的任何对象实例都满足空接口 `interface{}`, 所以 interface{} 看起来像是可以指向任何对象的 Any 类型，如下:
```go
    var v1 interface{} = 1          // 将 int 类型赋值给 interface{}
    var v2 interface{} = "abc"      // 将 string 类型赋值给 interface{}
    var v3 interface{} = &v2        // 将 *interface{} 类型赋值给 interface{}
    var v4 interface{} = struct{ X int }{1}
    var v5 interface{} = &struct { X int }{1}
```

当函数可以接受任意的对象实例时，可以将其声明为 interface{}，最典型的例子是标准 fmt 中的 print 系列函数:
```go
    func Printf(fmt string, args ...interface{})
    func Println(args ...interface{})
```

[测试](t/03_any.go)