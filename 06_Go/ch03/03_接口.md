
Go 语言的接口并不是其他语言中所提供的接口概念。

Java, C++ 中的接口具有"侵入式"特性，即先定义上层抽象接口，之后下层必须实现对应于该接口的方法，否则就无法实例化为对象。

在 Go 语言中，接口的定义和类的实现是没有必然关联的。如果一个类实现了接口要求的所有函数，我们就说这个类实现了该接口，该接口就可以调用这个类中的方法。

< 理解Go interface含义的关键是跳出C++等语言中关于接口的定义与实现 >

以下定义了一个 File 类及对应的一些成员方法:
```go
    type File struct {
        // ...
    }

    func (f * File) Read(buf []byte) (n int, err error)
    func (f * File) Write(buf []byte) (n int, err error)
    func (f * File) Seek(off int64, whence int) (pos int64, err error)
    func (f * File) Close() error
```

定义如下接口:
```go
    type IFile interface {
        Read(buf []byte) (n int, err error)
        Write(buf []byte) (n int, err error)
        Seek(off int64, whence int) (pos int64, err error)
        Close() error
    }

    type IReader interface {
        Read(buf []byte) (n int, err error)
    }

    type IWriter interface {
        Write(buf []byte) (n int, err error)
    }

    type ICloser interface {
        Close() error
    }
```
无论是接口 IFile, IReader, IWriter 或者 ICloser 都可以称为是 File 类的接口，尽管 File 类并没有从这些接口继承，甚至不知道这些接口的存在。
```go
    var file1 IFile = new(File)
    var file2 IReader = new(File)
    var file3 IWriter = new(File)
    var file4 ICloser = new(File)
```


### 接口赋值

在 Go 语言中，只要两个接口拥有相同的方法列表(无关次序)，那么它们就是等同的，可以相互赋值。

```go
    package one
    
    type ReadWriter interface {
        Read(buf []byte) (n int, err error)
        Write(buf []byte) (n int, err error)
    }

    package two

    type IStream interface {
        Write(buf []byte) (n int, err error)
        Read(buf []byte) (n int, err error)
    }
```
以上两个接口虽然位于不同的包内，且接口次序也不同，但这两个接口本质上并无区别。以下代码均可编译通过:
```go
    var file1 two.IStream = new(File)
    var file2 one.ReadWriter = file1
    var file3 two.IStream = file2
```

接口赋值并不要求两个接口必须等价。如果接口 A 的方法列表是接口 B 的方法列表的子集，那么接口 B 可以赋值给接口 A，但反过来并不成立。


### 接口查询
