
正则表达式在 Perl 里面通常也叫做模式(pattern)。

**注意，要匹配的目标串必须最好使用双引号括起来，否则会出现糟糕的事情。**

#### 特殊变量 @_

Perl 中，@_ 除了代表默认输入外，也代表模式匹配内容。

以一个简单模式匹配为例:
```pl
    $str = "yabba dabba doo";

    if ($str =~ /abba/) {
        print "It matched!\n";
    } else {
        print "Not matched!\n";
    }
```

上面的程序就等价于:
```pl
    $_ = "yabba dabba doo";

    if (/abba/) {
        print "It matched!\n";
    } else {
        print "Not matched!\n";
    }
```
在 if 判断中 `/abba/` 会去 $_ 中寻找字符进行匹配。第一处代码会将 $str 放到 $_ 中，而第二处代码则是直接给 $_ 赋值。二者执行效果是一样的。

下面的写法则是错误的:
```pl
    $str = "yabba dabba doo";

    if (/abba/) {
        print "It matched!\n";
    } else {
        print "Not matched!\n";
    }
```

[示例程序](../regex/special_variable.pl)

另外，则于模式匹配通常返回真或假值，所以往往会用在 if 或 while 的条件表达式里。


#### Unicode 属性

就像变量不仅有长度还有类型信息一样，字符除了字节组合之外，还带有属性信息。

所以除了根据字符本身匹配之外，还可以根据字符的属性来达成匹配。


#### 元字符

模式匹配中代表特殊含义的字符，通过它们使模式匹配不再局限于简单匹配。

| 元字符 | 描述 |
|:------:|:-----|
|   .    | 匹配除换行符以外的所有字符 |
|   []   | 匹配符合 [] 内的字符 |
|   [^]  | 匹配不符合 [] 内的字符 |
|   ^    | 匹配字符开头的字符 |
|   $    | 匹配字符结尾的字符 |
|   \d   | 匹配一个数字字符,和 [0-9] 语法一样 |
|   \D   | 非数字 |
|   \w   | 英文字母或数字的字符串,和 [a-zA-Z0-9_] 语法一样 |
|   \W   | 非英文字母或数字的字符串,和 [^a-zA-Z0-9_] 语法一样 |
|   \s   | 空格,和 [\n\t\r\f] 语法一样 |
|   \S   | 非空格,和 [^\n\t\r\f] 语法一样 |
|   \b   | 匹配以英文字母,数字为边界的字符串 |
|   \B   | 匹配不以英文字母,数值为边界的字符串 |

如果希望匹配到元字符本身，可以通过 '\' 进行转义。另外，'\' 也是一个元字符。

在正则表达式中，圆括号 `()` 的作用是对字符串分组，因此，圆括号也是元字符。

[示例程序](../regex/metacharacter.pl)


#### 量词

模式匹配中常常需要重复某些东西，而星号(`*`)正是用来匹配前面的条目零次或多次的。比如 `/fred\t*barney/` 能匹配 fred 和 barney 之间任意数量的制表符。

为什么要使用 `*` 这个符号代表重复多次，这是因为 `*` 是乘法(times)操作符，而英语里"times"也有"次数"的意思。

`/fred\t*barney/` 只能匹配中间有多个制表符的情况，如果制表符里面还夹杂着其他的符号，那么就会匹配失败。而通过 `.*` 则可以匹配任意字符。

量词及描述:

| 量词   | 描述 |
|:------:|:-----|
|   x*   | 贪婪匹配 0 次或多次 |
|   x+   | 贪婪匹配 1 次或多次 |
|   x?   | 匹配 0 次或一次 |
|   {m}  | 匹配刚好是 m 个 的指定字符串 |
| {m,n}  | 匹配在 m个 以上 n个 以下 的指定字符串 |
|   {m,} | 匹配 m个 以上 的指定字符串 |

`+` 或 `*` 后跟 `?` 表示惰性匹配，即尽可能少的匹配，如`*?` 重复任意次，但尽可能少重复。

[示例程序](../regex/quantifier.pl)


#### 模式分组

在正则表达式中，圆括号 `()` 的作用是对字符串分组。

模式 `/fred+/` 会匹配像 `freddddddd` 这样的字符串，但这种状况并不常见。不过，模式 `/(fred)+/` 会匹配像 `fredfredfred` 这样的字符串，这种状况却很常见。

通过模式分组，可以引用到目标串中符合模式串的字符串，这称为**反向引用**。而目标串中匹配到的字符串则称为**捕获组**。

反向引用的写法是在反斜线后面接上数字编号，比如 `\1`, `\2` 这样。相应的数字代表着对应顺序的捕获组。

```pl
    $_ = "abba";
    if (/(.)\1/) {
        print "It matched same character next to itself!\n";
    }
```
`(.)\1` 表示要匹配连续出现的两个同样的字符。

反向引用不必紧接在对应的捕获组括号后面。下面的模式会匹配 y 后面的 4 个连续的非换行符，并用 `\1` 反向引用表示匹配 d 后也出现这 4 个字符的情况:
```pl
    $_ = "yabba dabba doo";
    if (/y(....) d\1/) {
        print "It matched the same after y and d!\n";
    }
```

#### 择一匹配

| 表达式 | 描述 |
|:------:|:-----|
|  a|b|c |    匹配符合a字符或是b字符或是c字符的字符串 |
|   abc  |    匹配含有 abc 的字符串 (pattern)() 这个符号会记住所找寻到的字符串。第一个 () 内所找到的字符串通过 $1 或 \1 引用,第二个 () 内所找到的字符串通过 $2 或是 \2 引用,以此类推 |