
*错的不是程序，是自己和书籍。*

*if 总是最想要的，else 常常是不愿意看到的。*

*总以为实践出真知，但也可能颠覆三观。*


### 用 m// 进行匹配

之前用到的 `//` 是 `m//` 的简写。

因为习惯上将 `//` 作为定界符，但是通过 `m` 可以指定不同的定界符，这有时会很方便。

比如，`/http:\/\//` 会匹配起始的 "^http://"，但这样可读性太差了，这时就可以通过 `m` 来使用不同的定义符，其中一种如: `m%^http://%` 。


### 模式匹配修饰符

Perl 中的模式匹配修饰符(modifier)，也称作标志(flag)，是一些追加在模式表达式末尾定界符后面的字母，用来改变默认的匹配行为。

> 用 /i 进行大小写无关的匹配

要实现大小写无关的模式匹配，比如同时匹配 FRED、fred 和 Fred ，可以用 /i 修饰符:
```pl
    print "Would you like to play a game?";
    
    chomp($_ = <STDIN>);
    if (/yes/i) {
        print "In that case, I recommend that you go bowling.\n";
    }
```

> 用 /s 匹配任意字符

默认情况下，`.` 无法匹配换行号，添加 `/s` 标志就可以让 `.` 代表包括换行符在内的任意字符。
```pl
    $_ = "I saw Barney\ndown at the bowing alley\nwith Fred\nlast night.\n";
    if (/Barney.*Fred/s) {
        print "That string mentions Fred after Barney!\n";
    }
```
没有 `/s` 修饰符的话，上面的匹配就会失败，因为前后两个名字并不在同一行。


> 用 /x 加入空白符

该修饰符允许我们在模式时随意加上空白符，从而使其更易阅读和理解。

比如 `/-?[0-9]+\.?[0-9]*/` 看起来一团"糟"，而 `/ -? [0-9]+ \.? [0-9]* /x` 看起来就清楚多了。它们两个执行的是同样的效果。

加上 `/x` 修饰后，原来表示空格或制表符的空白符就失去了意义，Perl 会直接忽略。不过可以通过转义来避免这种情况，比如在空格前面加上反斜线、制表符使用 `\t` 等等。不过最常用的还是 `\s`(或者 `\s*`，抑或 `\s+`)，表示匹配空白符。

> /a /u /l ?

`/a` 表示仅在 ASCII 范围内阐释，这也是通常的做法。

`/u` 表示采取更宽泛的 Unicode 的匹配方式，相比 `/a` 可能会损失点效率。

`/l` 表示要按照本土化设定秋阐释简写的意义...这个吗，同样的匹配同样的字符串放在不同的环境下跑，可能会出现不同的效果呢。


> 组合选项修饰符

如果需要对单次匹配使用多项修饰符，只需要把它们接在一起写在模式末尾(顺序无关)。
```pl
    if (/barney.*fred/is) {
        print "That string mentions Fred after Barney!\n";
    }
```


### 锚位

默认情况下，如果给定模式不匹配字符串的开头，就会顺移到下一个字符继续尝试。而通过给定锚位，可以让模式仅在字符串指定位置匹配。

`\A` 锚位匹配字符串的绝对开头，即如果开头位置上不匹配，是不会顺移到下一个位置继续尝试的。
```pl
    m{\Ahttp?://}i
```

对应地，如果要匹配字符串的绝对末尾，可以用 `\z` 锚位。
```pl
    m{\.png\z}i
```

绝对末尾表示 `\z` 后面再无任何其他东西。对于单行内容的话，`\z` 前面会包括换行符。

行未锚位 `\Z` 允许后面出现换行符，这样就不必担心该怎么去掉单行内容末尾的换行符了。
```pl
    while (<STDIN>) {
        print if /\.png\Z/;
    }
```
看到上面的代码，第一反应是这是什么鬼! 然后回想一下，Perl 中 @_ 也可以代表默认输入。也就是说上面的语句是对 @_ 进行正则，将符合的 @_ 内容去掉后面的换行符后再 print 出来。

有时可能会同时使用行首锚位和行末锚位，以确保模式能匹配给定字符串的全部。如 `/\A\s*\Z/` 会匹配一个空行。

`\A \Z \z` 都是 Perl 5 里面的正则表达式特性，在 Perl 4 里，所用的表示字符串开头锚位的是脱字符 `^`，用于表示字符串结尾锚位的是 `$` 。这两种写法在 Perl 5 里也仍然适用。

但行首和字符串首严格来讲还是有区别的，所以在行匹配时，更建议使用 Perl 5 的正则特性。


#### 单词锚位

锚位并不局限于字符串首尾。比如 `\b` 是单词边界锚位，它匹配任何单词的首尾。比如 `/\bfred\b/` 可匹配 fred，但无法匹配 frederick、alfred 或 manfredmann 。这种匹配方式称为整词匹配。

整词匹配的并不完全等同于一般的英文单词，它是由一组 `/w` 字符构成的字符集，也就是由英文字母、数字与下划线组成的字符串。

非单词边界锚位是 `\B`，它能匹配所有 `\b` 不能匹配的位置。因此模式 `/\bsearch\B/` 会匹配 searches、searching 或 searched，但不能匹配到 search 或 researching 。


#### 绑定操作符 =~

默认情况下模式匹配的操作对象是 $_，绑定操作符 =~ 告诉 Perl ，用右边的模式来匹配左边的字符串，而不是 $_ 。
```pl
    my $some_other = "I dream of betty rubble";
    if ($some_other =~ /\brub/) {
        print "Aye, there's the rub.\n";
    }
```


#### 捕获变量

圆括号出现的地方一般都会触发正则表达式引擎捕获匹配到的字符串。捕获组会把匹配圆括号中模式的字符串保存到相应的地方。如果不止一个括号，也就不止一个捕获组。

每个捕获组包含的都是原始字符串中的内容，而不是模式本身。我们可以通过反向引用取得这些捕获内容，但也可以在匹配操作结束后立即通过相应的捕获变量取得这些内容。

既然这些捕获变量保存的是字符串，那就说明它是标量变量。Perl 中，它们的名称就是 `$1` 和 `$2` 这样的形式。模式中有多少个捕获括号，就有多少个对应名称的捕获变量可用。所以，变量 `$4` 的意思就是模式中第 4 对括号所匹配的字符串内容，这个内容和模式运行期间反向引用 `\4` 所表示的内容是一样的。但它们并非同一个事物的两种名称: `\4` 反向引用的是模式匹配期间得到的结果，而 `$4` 则是模式匹配结束后对得到的捕获内容的索引。

可以说，捕获变量是正则表达式无比强大的重要原因之一，因为它，我们才可以很好地提取字符串中某些特定的部分。

[示例程序](../regex/capture_variable.pl)

> 捕获变量的存续期

这些捕获变量通常能存活到下次成功匹配为止。也就是说，失败的匹配不会改动上次成功匹配时捕获的内容，而成功的匹配会将它们的值重置。

这就意味着，捕获变量只应该在匹配成功时使用，否则就会得到之前一次模式匹配的捕获内容。
```pl
    my $wilma = '123';
    $wilma =~ /([0-9]+)/;       # 匹配成功， $1 的内容是 123
    $wilma =~ /([a-zA-Z]+)/;    # 匹配失败， $1 的内容仍是 123
```

这也提醒我们，每次匹配之后，务必要进行判断。

当前的捕获变量在下次模式匹配成功会被覆盖，如果希望保存这个捕获变量，可以将它复制到某个普通变量里:
```pl
    if ($wilma =~ /([a-zA-Z]+)/) {
        my $wilma_word = $1;
        ...
    }
```

> 不捕获模式

目前所见的圆括号都会将捕获部分的匹配字符串放到捕获变量中，但有时候却需要关闭这个功能，而仅仅只是用它来进行**分组**。

比如某个模式中有些部分是可选的，之后的部分才是要捕获的:
```pl
    if (/(bronto)?saurus (steak|burger)/) {
        print "Fred wants a $2\n";
    }
```
上面的程序中，尽管有时 "bronto" 不存在，但还是得把 $1 变量留给它。

捕获时，在左括号后面加上问号和冒号(?:)，告诉 Perl 这一对圆括号仅为分组而存在，即跳过这个捕获:
```pl
    if (/(?:bronto)?saurus (steak|burger)/) {
        print "Fred wants a $1\n";
    }
```

[示例程序](../regex/non_capture.pl)

> 命名捕获

我们可以利用圆括号的捕获功能提取特定字符串并保存到诸如 $1 $2 这样的变量中。捕获变量增多后，对记忆是一个考验。

为此，Perl 5.10 增加了对捕获内容直接命名的写法。最终捕获到的内容会保存在特殊哈希 `%+` 里面: 其中的键就是在捕获时用的特殊标签，对应的值则是被捕获的字符串。具体写法为 `(?<LABEL>PATTERN)`，其中 LABEL 可以自行命名。

```pl
    my $names = 'Fred or Barney';
    if ($names =~ m/(?<name1>\w+) (?:and|or) (?<name2>\w+)/) {
        print "I saw $+{name1} and $+{name2}";
    }
```

使用捕获标签之后，反向引用的用法也随之有所变化。之前我们使用 \1 或 \g{1} 这样的写法，现在我们还可以使用 `\g{label}` 这样的写法，也更建议使用这样的用法。

```pl
    my $names = 'Fred Flintstone and Wilma Flintstone';
    if ($names =~ m/(?<last_name>\w+) and \w+ \g{last_name}/) {
        print "I saw $+{last_name}\n";
    }
```

[示例程序](../regex/named_capture.pl)


