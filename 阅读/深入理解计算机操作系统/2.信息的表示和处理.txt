1.CPU 在指令的要求下可能会执行以下操作：
  1）加载：把一个字节或者一个字从主存复制到寄存器，以覆盖寄存器原来的内容。
  2）存储：把一个字节或者一个字从寄存器复制到一个主存的位置，以覆盖这个位置上原来的内容。
  3）操作：把两个寄存器的内容复制到 ALU, ALU 对这两个字做算术操作，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。
  4）跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖 PC 原来的值。

2.1 信息存储
机器级程序将存储器视为一个非常大的字节数组，称为虚拟存储器。存储器的每个字节都由一个唯一的数字来标识，称为它的地址，所有可能地址的集合称为虚拟地址空间。
2.1.2 字
  1）每台计算机都有一个字长（word size），指明整数和指针数据的标称大小。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。
  2）今天大多数计算机的字长都是 32 位。
2.1.4 寻址和字节顺序
  1）在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。
  2）大端法：低地址存储高字节 IBM 或 Sun Microsystems
     小端法：低地址存储低字节 Intel兼容机
  3）程序应该把指针看成指向一个字节序列，而不是指向一个原始数据类型的对象。然后，这个指针会被看成是对象使用的最低字节地址。
2.1.10 C语言中的移位运算
  1）移位运算是从左至右可结合的，所以 x << j << k 等价于 (x << j) << k。
  2）一般而言，机器支持两种形式的右移：逻辑右移和算术右移。
  3）C 语言标准并没有明确定义应该使用哪种类型的右移。对于无符号数据，右移必须是逻辑的。而对于有符号数据，算术的或者逻辑的右移都可以。然而，实际上，几乎所有的编译器/机器
     组合都对有符号数据使用算术右移。
  4）对于一个由 w 位组成的数据类型，如果要移动 k >= w 位会得到什么结果呢？
     在许多机器上，当移动一个 w 位的值时，移位指令只考虑位移量的低 log2w 位，因此实际上位移量就是通过计算 k mod w 得到的。
	 不过这种行为对于 C 程序来说是没有保证的，所以移位数量应该保持小于字长。
  5）加法（和减法）的优先级比移位运算要高。
2.2 整数表示
2.2.2 无符号数的编码
  1）定义函数 B2Uw 为将一个长度为 w 的 0、1 串映射到非负整数。
  2）w 位所能表示的无符号数的范围：最小值用位向量 [00...0] 表示，也就是整数 0；最大值用位向量 [11..1] 表示，也就是整数 2^w - 1。
2.2.3 补码编码
  1）计算机常用补码表示有符号数。在这个定义中，将字的最高有效位解释为负权，用函数 B2Tw 来表示将一个长度为 w 的 0、1 串映射到有符号数。
  2）w 位补码所能表示的值的范围：最小值是位向量 [10...0]，其整数值为 -2^(w - 1)；最大值是位向量 [01...1]，其整数值为 2^(w - 1) - 1。
  3）补码的范围是不对称的，补码的最小值没有与之对应的正数，这导致补码运算的某些特殊的属性，并且容易造成程序中细微的错误。
  4）C 语言标准并没有要求用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。Java 标准明确规定采用补码表示。
  5）在 Java 中，单字节数据类型称为 byte，而不是 char, 而且没有 long long 数据类型。
2.2.4 有符号数和无符号数之间的转换
  1） B2Uw 和 B2Tw 都是双射，定义 U2Bw 和 T2Bw 分别为其逆映射。
  2）将函数 U2Tw(x) 定义为 U2Tw(x) = B2Tw(U2Bw(x)) 。此函数的输入是一个 0 ~ 2^w - 1 之间的数，结果得到一个 -2^(w - 1) ~ 2^(w - 1) - 1 之间的值。
  3）将函数 T2Uw(x) 定义为 T2Uw(x) = B2Uw(T2Bw(x)) 。此函数的输入与输出与 U2Tw 函数相反。
  4）T2Uw(x) = x + 2^w, (x < 0); x, (x >= 0);
  5) U2Tw(x) = u, (u < 2^(w - 1)); u - 2^w, (u >= 2^(w - 1));
  6）对大数 C 语言的实现而言，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。
2.2.5 C 语言中的有符号数与无符号数
  1）大多数数字都默认为是有符号的。要创建一个无符号常量，必须加上后缀字符 'U' 或者 'u'。
  2）C 语言允许无符号数和有符号数之间的转换。转换的原则是底层的位表示保持不变。
  3）当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么 C 语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算。这
     种转换有时会产生一些非直观的结果，如 -1 < 0U 运算结果为 false。
2.2.6 扩展一个数字的位表示
  1）将一个无符号数转换为一个更大的数据类型，我们只需要简单地在表示的开头添加 0，这种运算称为零扩展。
  2）将一个补码数字转换为一个更大的数据类型可以执行符号扩展，规则是在表示中添加最高有效位的值的副本。
  3）C 语言规定，进行类型之间的升阶转换时，先进行当前符号下的对应扩展，再完成符号的转换。
  4）unsigned short word;
	 (int)word << 24;		//先对 word 进行零扩展，再改变符号，之后左移
2.2.7 截断数字
  1）通过以下的例子感受
     int	x = 53191;
	 short	sx = (shore)x;		/* -12345 */
	 int y = sx;				/* -12345 */
  2）将一个 w 位的数 [Xw-1, Xw-2, ..., X0] 截断为一个 k 位数字时，我们会丢弃高 w - k 位，得到一个位向量 [Xk-1, Xk-2, ..., X0] 。
  3）无符号数的截断结果是：
		B2Uk([Xk-1, Xk-2, ..., X0]) = B2Uw([Xw-1, Xw-2, ..., X0]) mod 2^k
  4）补码数字的截断结果是：
		B2Tk([Xk-1, Xk-2, ..., X0]) = U2Tk(B2Uw(Xw-1, Xw-2, ..., X0) mod 2^k)
2.2.8 关于有符号数与无符号数的建议
  有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为。这可以通过两个 buggy code 来说明：
  1）float sum_elements(float a[], unsigned length){
		int i;
		float result = 0;
		for (i = 0; i <= length - 1; i++)	// length 取值为 0 时会使判断表达式总是为真
			result += a[i];
		return result;}
  2）size_t strlen(const char* s);
     int strlonger(char *s, char *t){
		return strlen(s) - strlen(t) > 0;}		// 只要 s 与 t 不等，结果总是为真
  3）除了以下几种情况，要避免使用无符号数
     ① 仅看做是位的集合，如往一个字中放入描述各种布尔条件的标记(flag)时；
	 ② 表示地址时；
	 ③ 实际模运算和多精度数学时，数字是由字的数组来表示的；
	 ④ 数据流；
2.3 整数运算
2.3.1 无符号加法
  1）对于 w 位无符号数加法，其等价于计算和模上 2^w 。可以通过简单的丢弃 w + 1 位表示的最高位，来计算这个数值。
  2）一个算术运算溢出，是指完整的整数结果不能放到数据类型的字长限制中去。
  3）当执行 C 程序时，不会将溢出作为错误而发信号。
  4）w 位的无符号数 x 和 y 进行加法计算，其和为 s。可以通过 s < x (或 s < y) 来判断发生了溢出。
  5）无符号加法防溢出程序
	 int uadd_ok(unsigned x, unsigned y){
		unsigned sum = x + y;
		return sum >= x;}	// 如果参数 x 和 y 相加不会产生溢出，则返回 1
  6）模数加法形成了一种数学结构，称为阿贝尔群。其性质如下：
     ① 它是可交换的和可结合的；
	 ② 有一个单元 0；
	 ③ 每个元素有一个加法逆元
  7）w 位的无符号数 x 的加法逆元： x, (x = 0); 2^w - x, (x > 0)
2.3.2 补码加法
  1）w 位补码编码数 x 和 y 进行加法计算公式： U2Tw[(x + y) mod 2^w] 。
  2）补码加法运算有三种可能的运算结果：正溢出、正常、负溢出。
  3）正溢出得到的结果比实际小 2^w，负溢出得到的结果比实际大 2^w。w 为当前类型的比特位数，如 int 类型的 w 为 32。
  4）补码加法防溢出程序
     int tadd_ok(int x, int y){
		int sum = x + y;
		int neg_over = x < 0 && y < 0 && sum >= 0;
		int pos_over = x >=0 && y >= 0 && sum < 0;
		return !neg_over && !pos_over;}		// 如果参数 x 和 y 相加不会产生溢出，则返回 1
2.3.3 补码的非
  1）补码的非运算：
		-2^(w - 1), x = -2^(w - 1);
		-x,			x > -2^(w - 1);
2.3.4 无符号乘法
  1）w 位无符号乘法运算结果为：
		(x · y) mod 2^w
2.3.5 补码乘法
  1）w 位补码乘法运算结果为：
		U2Tw((x · y) mod 2^w)