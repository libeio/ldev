
## 什么是设计模式
- 设计模式是通常的设计问题的解决方案，这类问题以一组交互类的形式出现，需要由用户根据
  需要定制这些交互类以形成专门的设计。
- 可以简单的将设计模式理解为一组经验公式。

## 为什么要学习设计模式
- 快速理解代码组成
    + 维护或迭代一个项目，类的层次结构很复杂，各种继承，各种聚合，看了后面忘记前面，
      无法掌握整个项目的大致脉络或对某一局部的实现很疑惑，怎么办？可以尝试从设计模式
      的角度进行理解。
    + 通常，一个良好项目的码农，纵使平时不关注或不太了解设计模式，在编写项目的过程中
      ，也会尽量去做到对他人友好可读，而这很可能会无意中显现出一些设计模式的影子。而
      作为读者就可以根据这些痕迹去慢慢理会项目的组成。
- 更好更快的项目重构
    + 需要重构的项目一般是较难维护的，原因可能是可读性差一些，或者是思想性较为跳跃。
      这时可以通过引入适当的设计模式来避免或减少上述状况。
- 模块分离及重用
    + 降低代码之间的耦合性，可以有效设计更良好的测试用例。
    + 提高代码的可重用性。
- 简化维护
    + 这是必然的。
- 统筹的需要
    + 一个模块或功能可以需要很多类来组成实现，根据其特征以相应的设计模式实现，可以高
      效地并行分配开发任务。
- 以上纯属个人理解，可能有些偏颇。

## 设计模式的种类
- 创建者模式
    + Abstract factory(抽象工厂)         创建几个类家族的一个实例
    + Builder（创建者）                  允许相同结构的过程创建不同的实现
    + Factory method(工厂)               创建几个可能的衍生类的一个实例
    + Prototype(原型)                    要被克隆的一个类
    + Singleton(单例)                    限制一个类的实例化只能为一个实例
- 结构类模式
    + Adapter(适配器)                    适配不同类的接口
    + Bridge(桥接)                       从实现中分离出抽象
    + Composite(合成器)                  相似类的合成类
    + Decorator(装饰器)                  允许给类动态地添加额外的特性
    + Facade(窗口)                       提供简化接口的单类
    + Flyweight(享元)                    用共享机制来有效地支持大量细粒度类
    + Proxy(代理)                        起到接口功能的类
- 动作类模式
    + Chain-of-responsibility(责任链)    通过类链来处理申请的方式
    + Command(命令)                      在类中封装一个行为
    + Interpreter(解释器)                应用特定语言元素的方式
    + Iterator(迭代器)                   频繁地访问集合元素
    + Mediator(中介者)                   为一组接口提供统一的接口
    + Memento                            捕获并存储对象的内部状态
    + Observer(观察者)                   允许在运行时观察对象的状态
    + State(状态)                        允许在运行时动态选择算法
    + Template method(模板方法)          将算法在实现延迟到子类中
    + Vistor(访问者)                     不改变类的情况下给类添加新的操作
    
## 设计模式原则
- [单一职责原则](/设计模式原则/单一职责原则.md)
- [接口隔离原则](/设计模式原则/接口隔离原则.md)
- [依赖倒转原则](/设计模式原则/依赖倒转原则.md)
