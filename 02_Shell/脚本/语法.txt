
参考：
	shell 十三問?
	http://bbs.chinaunix.net/forum.php?mod=viewthread&tid=218853&extra=&authorid=7696299&page=1
	shell中的cat和文件分界符
	https://www.cnblogs.com/jinjiangongzuoshi/p/3679098.html

常用的系统变量
	表示	含义
	$n		$1表示第一个参数，$2表示第二个参数
	$#		命令行参数的个数
	$0		当前程序的名称
	$?		前一个命令或函数的返回码
	$*		命令行中输入的全体参数列表的清单
	$@		含义同s*，但它不使用IFS环境变量
	$$		本程序的PID（进程ID号）
	$!		上一个命令的PID

环境变量
1. 使用env命令可以查看系统中所有环境变量的值。
2. 在 /etc/profile 中可以添加修改系统的环境变量，这种修改方式对所有的用户都生效，而且是永久性的。
   例如在 /etc/profile 文件中增加环境变量CLASSPATH，只需在该文件中添加以下内容：
		export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib
   修改文件保存后，若想要马上生效还需要运行下面的命令：
		source /etc/profile
3. 也可以直接使用 export 在 shell 命令行下修改环境变量。但这只是对当前的连接终端有效，并且修改是
   临时性的，终端关闭后变量就失效了，再打开新的终端时没有这个变量，如果需要使用还需要重新定义。
4. Shell 可以用 export 把它的变量向下带入子 Shell，从而让子进程继承父进程中的环境变量。但子 Shell   
   不能用 export 把它的变量向上带入父 Shell。
5. 当 Shell 执行到 exec 语句时，不会去创建新的子进程，而是转去执行指定的命令，当指定的命令执行完时
   ，该进程就终止了，所以，Shell 程序中 exec 后面的语句将不再被执行。
	
通配符
	操作符		功能
	\			将下一个字符标记为原义字符，例如 "\$" 表示 "$"
	.			匹配任何单个字符，例如 "a.b" 可匹配 acb、alb等，注意也可以匹配空格符
	?			之前的字符最多出现一次，例如 "tes?t" 可匹配 test 或 tet
	*			之前的字符可出现零次或者多次，例如 "0*1234" 可匹配 1234、01234或0001234等
	+			之前的字符至少出现一次，例如 "go+gle" 可匹配 gogle、google或goooogle等
	{N}			精确匹配N次之前的字符，例如 "o{2}" 可匹配 book、good，但不能匹配 sooop
	{N,}		至少匹配N次之前的字符，例如 "o{2,}" 可匹配 book、goodd，但不能匹配sop
	{N,M}		先前的字符至少匹配N次，但是不多于M次
	^			匹配字符串开始的位置
	$			匹配字符串结束的位置
	\b			匹配字符串边界的位置，例如 "ee\b" 可匹配 bee，但不能匹配 feed
	\B			匹配字符串，但不得为边界，例如 "ee\b" 可匹配 feed，但不能匹配 bee
	x|y			匹配字符串x或y，例如 "good|bad" 可匹配 good 或 bad
	[xyz]		匹配包含的字符x、y或z，例如 "abc" 可匹配 black 中的 a
	[^xyz]		匹配未包含x、y或z的字符，例如 "^abc" 可匹配 black 中的 b、l、c 或 k
	[a-z]		匹配字符的范围，由 a~z
	[^a-z]		不匹配字符的范围，a~z之外的字符，如1或2
注：-只在方括号内有效，*和?只在方括号外有效，否则均视为普通字符

三个引号
1. 单引号：
   括起来的字符都视为普通字符。
2. 双引号：
   忽略大多特殊字符，但三种不被忽略：$、\、`。即双引号会解释这三个字符的特殊含义。
3. 反引号：
   其括起来的字串被Shell解释为命令行，在执行时，Shell首先执行该命令行，并以它的标准输出为结果取代
   整个反引号部分。
   反引号可嵌套使用，此时内层反引号必须用反斜线\将其转义。先执行内层嵌套，再执行外层嵌套。
	
test 命令
1. 在 if 语句中测试一种或几种条件。实际上，在大多数的 Shell 程序中都会大量使用"test"命令，它的另一种
   写法是[]
		test "$LOGNAME" = lb
		[ "$LOGNAME" = lb ]
   注意：等号两边、方括号与被判断的条件表达式之间均要留出空格。
2. test字符串操作符
	操作符				返回真（退出状态为0）的条件
	string1 = string2	两字符串完全相同		等号两边要加空格！！！！！
	string1 != string2	两字符串不同
	string 				字符串不为空
	-n string			字符串不为空（并且test能够看到string）
	-z string			字符串为空（并且test能够看到string）
3. test整数操作符
	操作符				返回真（退出状态为0）的条件
	a -eq b				a等于b
	a -ne b				a不等于b
	a -gt b				a大于b
	a -ge b				a大于等于b
	a -lt b				a小于b
	a -le b				a小于等于b
4. test文件操作符
	操作符				返回真（退出状态为0）的条件
	-b file				file为特殊块文件
	-c file				file为特殊字符文件
	-d file				为目录名
	-e file				文件存在
	-f file				为普通文件名
	-h file				为链接文件
	-k file				已经设置了sticky位
	-L file				为符号链接文件
	-p file				为命名管道
	-r file				文件可读
	-S file				为套接字
	-s file				文件长度不为0
	-u file				文件的SUID位已经设置
	-w file				文件可写
	-x file				文件可执行
5. 逻辑操作符
	操作符				含义				返回真（退出状态为0）的条件
	!exp				非					表达式exp值为假
	exp1 -a exp2		与					两表达式均为真
	exp1 -o exp2		或					至少一个为真
	exp1 && exp2		与（短路性质）		均为真
	exp1 || exp2		或（短路性质）		至少一个为真

判断结构
1. if语句 
	if 条件表达式 ; then
		命令序列
	fi
2. if...else语句
	if 条件表达式 ; then
		命令序列1
	else
		命令序列2
	fi
3. if...elif语句
	if 条件表达式 ; then
		命令序列1
		elif 条件表达式2 ; then
			命令序列2
		else
			命令序列3
	fi
3. case 语句
	case 变量 in
	值1)
		命令序列1;;
	值2)
		命令序列2;;
	...
	值n)
		命令序列n;;
	*)
		其他序列;;
注意：如果同一个操作（命令序列）对应多个操作，则使用"|"隔开。

循环结构
1. for语句
	for 变量 in 参数1 参数2 ... 参数n
	do
		命令序列
	done
注意：决定命令列表是否继续循环执行的条件是一个命令的返回值。test命令常常被用来控制一个循环是否继续。

2. 不带参数列表并省略关键字 in 的 for 语句，Shell会自动将命令行输入的所有参数依次组织成列表
	for 变量
	do
		命令序列
	done
	等同于
	for 变量 in $*
	do
		命令序列
	done
3. while语句
	while [ 条件表达式 ]	#条件表达式退出状态为0，就执行循环
	do
		命令序列
	done
4. until语句
	until [ 条件表达式 ]
	do
		命令序列
	done

shift 命令
1. while 循环语句（包括后面的until语句）通常和 shift 命令结合使用，以处理命令行中输入的参数个数可
   变的情况。使用 shift 命令可以依次移动命令行参数的位置，即$2->$1，$3->$1......而移位之前的前一个
   位置参数在移位后将自动消失。每进行一次移位，$#自动减1。
2. 使用 shift 命令的另一个原因是，Bourne Shell 的位置参数变量为$1~$9，因此通过位置变量最多只能访
   问9个参数。但这并不等于在命令行上最多只能输入9个参数，此时如果想访问多于9个的参数，就必须使用
   shift命令。
3. 另外，shift命令后可加整数参数进行一次多个移位，如shift 3，表示一次移动3个位置的参数。

定义函数
	函数名()
	{
		命令序列
	}
	或
	function 函数名()
	{
		命令序列
	}
1. 函数可以放在同一个文件中作为一段代码，也可以放在只包含函数的单独文件中。
2. 归纳起来，Shell函数的定义和使用可分为以下三种情况：
	在Shell终端的交互式环境下定义和使用函数；
	在Shell脚本程序中定义和使用函数，使其成为Shell程序的一部分；
	在一个单独的文件中定义函数，Shell程序调用该函数。

Shell脚本中定义和使用函数
Shell程序中的函数必须在使用前进行定义，因此一般将函数的定义放在脚本开始的部分。
3. 将函数定义在单独的文件中
   将函数定义在一个单独的Shell脚本中，然后将函数文件载入Shell。一旦文件载入Shell，就可以在命令行或
   脚本中像输入普通命令一样通过函数名来调用函数。
4. 文件创建完毕后，需要将函数文件载入 Shell 中，载入文件的格式为：
	<点><空格><文件名>
   可以使用set命令检查是否已经成功载入。
   使用 unset 命令，可以将函数从 Shell 中卸载。
   如需改动函数，则应首先使用unset命令从Shell中删除函数，改动完毕后，再重新载入此文件。

定义自己的变量
	变量名＝变量值
在定义变量时，变量名前不应加符号"$"，在引用变量的内容时，则应在变量名前加"$"。

bash程序的调试
	Shell程序的调试主要是利用bash命令解释程序的选择项。调用bash的格式为：
		bash -选择项 Shell 程序文件名
	几个常用的选择项如下：
		-e：如果一个命令失败就立即退出
		-n：测试Shell脚本语法结构，只读取Shell脚本但不执行
		-u：置换时把未设置的变量看作出错
		-v：当读入Shell输入行时把它们显示出来
		-x：执行命令时把命令和它们的参数显示出来
		-I：交互方式
		-k：从环境变量中读取命令的参数
		-t：执行命令后退出
	上面的所有选项也可以在Shell程序内部用"set -选择项"的形式引用，而"set
	+选择项"则将禁止该选择项起作用。

命令分组
1. 在Shell中有两种命令分组的方法：()和{}。
2. 前者当 Shell 执行 () 中的命令时将再创建一个新的进程，然后这个子进程去执行圆括号中的命令。
   当用户在执行某个命令时，不想让命令运行时对状态集合的改变影响到下面语句的执行时，就应该把这
   些命令放在圆括号中，这样就能保证所有的改变只对子进程产生影响，而父进程不受任何干扰。
3. {}用于将顺序执行的命令的输出结果用于另一个命令的输出。
4. 当要真正使用圆括号和花括号时，则需要在其前面加上转义符 \。

命令替换
1. 命令替换指的是用命令的输出来代替该命令。在BASH下，命令替换时优先使用下列语法：
	$(command)
2. 当然，在BASH下，还可以使用下面的语法：
	`command`
3. 示例：
	nowIn=$(pwd)
	echo $nowIn

算术扩展
1. shell 计算算术表达式的值，并用该值替换表达式，这就是算术扩展。在BASH下，算术表达式的语法如下：
	$((expression))
2. shell 计算 expression 表达式的值，并用其计算的结果代替$((expression)).
3. 可以不用在 expression 中的变量名称前加上美元符号$，但不作强制要求。
4. 示例：
	s=15 t=79
	echo $((3*s+4*t))
	
[] 和 [[]]
1. [[]] 结构比 [] 结构更加通用。这是一个扩展的 test 命令，支持通配符。
2. 在 [[ 和 ]] 之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。
3. 使用 [[]] 条件判断结构，能够防止脚本中的许多逻辑错误，比如，&&、||、<、和>这些操作符能够正常
   存在于 [[]] 这个条件判断中，但是如果出现在 [] 中，就会报错。
	
heredoc 写法
用法：
	最简单：
		cat<<EOF
		>...
		>EOF
	把输出追加到文件（写法一）：
		cat<<EOF>out.txt
		>...
		>EOF
	把输出追加到文件（写法二）：
		cat>out.txt<<EOF
		>...
		>EOF


一次性定义多个变量
	local a b c
	
shell 字符串的掐头去尾处理
# 表示掐头，% 表示去尾。
助记：键盘上的排列，# 在前面，% 在后面。
单个 # 或 % 的表示最小匹配，双个 # 或 % 表示最大匹配。
也就是说，当匹配有多种方案的时候，选择匹配最大长度还是最小长度。
如：workspace为/home/user/test.txt，则 %/* 最小匹配只会去除/test.txt；而 %%/* 会去除最长字串 /home/user/test.txt，即整个字串都被去除了。

四种模式匹配替换结构
1. # 去掉左边， % 去掉右边
2. ${var%pattern} shell 在 var 中查找，看它是否以给定模式 pattern 结尾，如果是，就从 var 中去掉右
   边最短的匹配字符串。
3. ${var%%pattern} shell 在 var 中查找，看它是否以给定模式 pattern 结尾，如果是，就从 var 中去掉右
   边最长的匹配字符串。
4. ${var#pattern} shell 在 var 中查找，看它是否以给定模式 pattern 结尾，如果是，就从 var 中去掉左
   边最短的匹配字符串。
5. ${var##pattern} shell 在 var 中查找，看它是否以给定模式 pattern 结尾，如果是，就从 var 中去掉左
   边最长的匹配字符串。

字符串提取和替换
1. ${var:pos}  pos 为索引，为正时表示自 pos 位置开始向后的所有字符；为负时则从左起
2. ${var:pos:num} 从 pos 位置开始向后的 num 个字符
3. ${var/pattern1/pattern2} 将 var 字符串中第一个符合 pattern1 匹配的替换为 pattern2
4. ${var//pattern1/pattern2} 将 var 字符串中所有符合 pattern1 匹配的替换为 pattern2
   
/dev/null 和 /dev/zero
1. /dev/null 又称空设备，它会丢弃一切写入它的数据，但是读取它则会抛出错误。在 shell 中常用它来
   表示放弃执行的结果（或者错误）。
2. /dev/zero 设备用于提供无限制的空 null 供读取，主要用途是提供字符流来初始化数据存储，也就是使
   用空字符覆盖目标数据。/dev/zero 也支持写入，可以用做数据黑洞。

整数运算
一般通过 let 和 expr 这两个命令实现
	let "a=$a + 5"
	let "a += 1"
	let "n=n ** 4"		# n的4次幂运算
	a=`expr $a + 5`