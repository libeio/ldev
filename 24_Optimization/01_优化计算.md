
### 使用位操作运算代替余数运算

可以使用位操作运算代替一般求余数运算。在对无符号整数执行算术运算时，若 `b = 2^n - 1`, 则可以将 `a & b` 理解为 `a % (b + 1)` 。

如把 `a = w % 8` 变成 `a = w & 7` 。

可用于循环队列、哈希表的计算当中。

[测试程序](t_01/mod2power.cpp)


### 使用加法运算代替乘法运算

加法运算比乘法运算快。在可能的情况下，可以把乘法运算变换成加法运算，如把 `3 * w` 变换成 `w + w + w`，把 `n * 31` 变换成 `n << 5 - n`。

[测试程序](t_01/mul2plus.cpp)


### 使用乘法运算代替除法运算

除法运算较乘法运算慢，因此，可以把除法式运算变换成乘法式运算。

例如，把 `a / b > c` 变成 `a > c * b`，这里假定 b 为正数。再如，把 `y = x / 3` 变成 `y = x * (1.0 / 3.0)`，其中括号里的数在编译时就被计算出来了。


### 使用位操作和加减法运算代替乘除法运算

因为位操作运算和加减法运算比一般的乘除法运算快，因此可使用位操作和加减法运算代替乘除法运算，如把 `a = y * 65` 变成 `a = (y << 6) + y`。

在循环结构中，可以使用加法运算代替乘法运算，示例如下。

变换前:
```c
    for (i = 0; i < 100; i++) {
        r[i] = i * w;
    }
```
变换后:
```
    for (i = 0, t = 0; i < 100; i++) {
        r[i] = t;
        t += w;
    }
```

或者，通过改变循环上限和步长，把乘法计算变成加法计算，示例如下。

变换前:
```
    for (i = 0; i < 10; i++) {
        x = i * 10;
    }
```
变换后:
```
    for (i = 0; i < 100; i += 10) {
        x = i;
    }
```


### 使用代数式代替函数调用

由于使用表达式计算比函数调用计算步骤少，因而计算速度较快。因此，应尽量使用表达式计算代替函数调用计算，特别要避免使用超越函数，如 `sin, exp log` 等，如把 `a = pow(x, 2.0)` 变成 `a = x * x` 。


### 使用查表代替计算

如果某种参数的计算方法是固定的，且计算较复杂，则可以把它事先计算出来，保存在内存中，或者列成一张表，以便后面的计算直接使用或查表。这样可以避免重复计算，节省时间，示例如下:

一般计算:
```
    long fib(int n) {
        if (n <= 2) return 1;
        
        return fib(n - 1) + fib(n - 2);
    }
```

查表:
```
    static long fib_table[] = {
        1, 1, 2, 3, 5, 8, 13, 21, 34, 55,
    };
    
    long fib(int n) {
        return fib_table(n);
    }
```


### 减少指针链

对于下列结构:
```
    typedef struct { int x, y, z; } TriDimension;
    typedef struct { TriDimension pos; } Balloon;
```

变换前:
```
    void setpos(Balloon * p, int x, int y, int z)
    {
        p->pos->x = x;
        p->pos->y = y;
        p->pos->z = z;
    }
```

变换后:
```
    void setpos(Balloon * p, int x, int y, int z)
    {
        Balloon * pos = p->pos;
        pos->x = x;
        pos->y = y;
        pos->z = z;
    }
```


### 使用 binary 或 unformatted 代替 formatted 文件读写

在文件读写时，数据格式的标准化需要花费一定的时间，因此使用 binary 或者 unformatted 格式数据读写速度相对较快。
