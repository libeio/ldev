### Debian下安装 gcc8.1.0 ###

1.下载gcc tar 包并解压，进入文件中执行
	./contrib/download_prerequisites
检测并自动下载相关信赖包
	gmp-6.1.0.tar.bz2
	mpfr-3.1.4.tar.bz2
	mpc-1.0.3.tar.gz
	isl-0.18.tar.bz2
2.创建目录
	mkdir /usr/local/gcc8.1 				//安装目录
	mkdir /usr/local/gcc8.1-depend			//依赖包安装目录
	mkdir /usr/local/src/gcc-build-8.1.0	//build目录
3.安装gcc信赖包
编译安装gmp-6.1.0.tar.bz2
	1.解包
	cd /usr/local/gcc8.1-depend
	tar -jxvf gmp-6.1.0.tar.bz2
	2.信赖包校验及初始化配置	如果要对所作配置清除处理，使用 make distclean
	cd gmp-6.1.0
	./configure --prefix=/usr/local/gcc8.1-depend/gmp CC="gcc -std=c11"
	3.编译
	make
	4.优化 为了与mpfr库更协调
	cd tune
	make speed
	5.安装
	cd ..
	make install
	6.安装完成后可以通过环境变量形式设置搜索路径，下面的依赖包同样执行
	C_INCLUDE_PATH  	指定头文件搜索路径环境变量
	LIBRARY_PATH		指定库文件搜索路径环境变量
	LD_LIBRARY_PATH		指定动态库搜索路径环境变量	-> 在这里只需设置这个即可
	LD_RUN_PATH			指定动态库搜索路径环境变量
	7.参考文件 都在tar包中
	README
	INSTALL
	INSTALL.autoconf	
编译安装mpfr-3.1.4.tar.bz2
	0.前提
	确保在这之前安装gmp，版本在4.1及以上
	1.解包
	cd /usr/local/gcc8.1-depend
	tar -jxvf mpfr-3.1.4.tar.bz2
	2.下载补丁并更新
	cd mpfr-3.1.4
	wget http://www.mpfr.org/mpfr-3.1.4/allpatches
	patch -N -Z -p1 < allpatches
	3.信赖包校验及初始化配置
	./configure --prefix=/usr/local/gcc8.1-depend/mpfr \
				--with-gmp=/usr/local/gcc8.1-depend/gmp \
				CC="gcc -std=c11"
	4.编译
	make
	5.优化协调	此命令执行报错，执行 make -i tune 可以完成执行，但不是个好办法
	cd tune
	make tune
	6.校验测试	如果校验出错，执行 VERBOSE＝1 make check 打印出错信息
	cd ..
	make check
	7.安装
	make install
	8.生成文档
	如果需要生成一些格式文档，需安装texinfo库
	make info
	make pdf
	make dvi
	make ps
	make html
	9.可能出现错误及解决方法（并未遇到过）
	初始化配置出错
		检查C编译器选项与类型是否与GMP一致
		GMP C编译器选项与类型可通过下列命令查询
			grep "^CC\|^CFLAGS" GMPBUILD/Makefile
		之后使用与GMP一致的CC与CFLAGS重新初始化配置
			./configure <configure options> CC=<C compiler> CFLAGS="<compiler options>"
	校验测试出错
		可能的出错行显示 checking for TLS support... 未通过
		尝试在初始化配置中加入 --disable-thread-safe 选项
	编译器优化出错
		在初始化配置中在CFLAGS选项中将优化项改 -O0 ，之后重新配置、编译、安装。如果成功安装，说明确实是这个错误。
	头文件与库文件不一致
		报错现象 undefined reference to `__gmp_get_memory_functions'
		调整搜索路径或设置环境变量解决	
	尝试用 nmake 代替 make 编译
编译安装mpc-1.0.3.tar.gz
	0.前提
	确保在这之前安装gmp，版本在4.3.2及以上
	确保在这之前安装mpfr，版本在2.4.2及以上
	1.解包
	cd /usr/local/gcc8.1-depend
	tar -zxvf mpc-1.0.3.tar.gz
	2.信赖包检验及初始化配置
	./configure --prefix=/usr/local/gcc8.1-depend/mpc \
			--with-gmp=/usr/local/gcc8.1-depend/gmp \
			--with-mpfr=/usr/local/gcc8.1-depend/mpfr \
			CC="gcc -std=c11"
	3.编译
	make
	4.检测
	make check
	5.安装
	make install
	6.生成文档
	make dvi
	make ps
编译安装isl-0.18.tar.bz2
	1.解包
	cd /usr/local/gcc8.1-depend
	tar -jxvf isl-0.18.tar.bz2
	2.信赖包检测及初始化配置
	cd isl-0.18
	./configure --prefix=/usr/local/gcc8.1-depend/isl \
			--with-gmp-prefix=/usr/local/gcc8.1-depend/gmp \
			CC="gcc -std=c11" \
	3.编译安装
	make && make install
4.安装gcc8.1.0
	1.初始化配置
	cd /usr/local/src/gcc-build-8.1.0
	../gcc-8.1.0/configure --prefix=/usr/local/gcc8.1 \
		    --with-mpc=/usr/local/gcc8.1-depend/mpc \
		    --with-mpfr=/usr/local/gcc8.1-depend/mpfr \
		    --with-gmp=/usr/local/gcc8.1-depend/gmp \
		    --with-isl=/usr/local/gcc8.1-depend/isl \
		    --disable-multilib \
			--enable-checking=release \
			--enable-languages=c,c++ \
			--disable-bootstrap
	2.编译 时间较长 gcc的编译与安装均较容易出现错误，所以分开执行
	make
	3.安装
	make install
	4.出错
	如果编译时出错，很可能是 ./configure 设置不对，可以尝试修改 ./configure 选项设置
	配置设置参考下面的 [how to configure gcc]

###### CERTAIN GCC SETOPTION ######
[how to configure gcc]
srcdir - gcc source 最顶层目录
objdir - gcc build 最顶层目录

目录分离
	srcdir 目录与 objdir 目录分开，后者也不应作为前者的子目录存在
目标指定
	编译本地gcc时不要进行 target 配置
	交叉编译gcc时一定要使用 --target=target 选项
选项指定 选项有许多，但这里只选取部分常用项
	--prefix=dirname	
		推荐使用指定安装目录，此目录最好与objdir目录独立，也不要置于 home 目录树下
	--enable shared[=package[,...]]
		编译动态库，package可以是libgcc、libstdc++、libffi、zlib、boehm-gc、ada、libada、libgo、libobjc。注意libiberty不支持动态库编译。
	--disable shared
		只编译静态库
	--enable-host-shared
		编译 libgccjit.so 库时需指定
	--disable-multilib
		库虽然在本地生成，但在其他指定平台下工作下依然可以使用，常与 --with-multilib-list=list 或 --without-multilib-list 合用
		可以指定的平台有：
			arm-*-*
				fpu,26bit,underscore,interwork,biendian,nofmult
			m68*-*-*
				softfloat,m68881,m68000,m68020
			mips*-*-*
				single-float,biendian,softfloat
			powerpc*-*-*,rs6000*-*-*
				aix64,pthread,softfloat,powercpu,powerpccpu,powerpcos,biendian,sysv,aix
	--with-multilib-list=list
		list是逗号分隔的列值，目前只能执行 arm*-*-*,riscv*-*-*,sh*-*-*和x86_64-*-linux*
		如果list为空，则只提供在x86-64平台 32bit 和 64bit 下的运行库
	--enable-threads[=lib]
		指定可以使用gcc进行多线程编译的库  IMHO:omit it
	--disable-threads
		等价于 --enable-threads=single
	--enable-tls
		指定gcc支持tls（线程本地存储）
	--disable-tls
		指定gcc不支持tls
	--disable-bootstrap
		本地创建gcc时，执行make后会进行 3-stage 以测试能否使用当前环境下gcc完成自举编译过程。（此过程耗时很长且极易报错，强烈建议加上）
		使用此选项可以不执行此过程。
	--enable-bootstrap
		默认选项。	IMHO:configure it when plan to carry out a cross compile process
	--enable-languages=lang1,lang2,...
		指定gcc可以编译的语言类型，可选项有：
			all,defalut,ada,c,c++,fortran,go,jit,lto,objc,obj-c++
		如果不指定此选项，会默认支持 c,c++,fortran,lto,objc 语言编译
	--enable-stage1-languages=lang1,lang2,...
		在自举的 stage 1 阶段通过系统c编译器创建所指定的编译语言运行库，语言类型同 --enable-languages 选项设置	IMHO:omit it, for gcc developer
	--enable-default-pie
		指定gcc编译时默认开启 -fPIE 和 -pie 选项
	--enable-checking[=list]
		编译器内部增加错误检测，使本地GCC创建gcc时更合理。默认为 yes 。 PLZ:use release instead of yes, check 'assert,runtime'
	--enable-stage1-checking[=list]
		list值与 --enable-checking 项值相同
	--disable-stage1-checking
		如果自举过程太慢，可以设置此选项
	--enable-nls
		开启本地语言支持，默认开启
	--disable-nls
		关闭本地语言支持
	--with-gmp=pathname
	--with-gmp-include=pathname
	--with-gmp-lib=pathname
	--with-mpfr=pathname
	--with-mpfr-include=pathname
	--with-mpfr-lib=pathname
	--with-mpc=pathname
	--with-mpc-include=pathname
	--with-mpc-lib=pathname
	--with-isl=pathname
	--with-isl-include=pathname
	--with-isl-lib=pathname
		指定依赖库安装路径，如果 --with-xxx 方式报错，尝试使用 --with-xxx-include 和 --with-xxx-lib 方式代替。
		同时要确保共享库可以被动态链接器找到，可以使用 LD_LIBRARY_PATH 设置。 IMHO:ldconfig also may do it
		不适用于创建交叉编译器
交叉编译指定项 仅用于创建交叉编译器
	用到时再看
###### CERTAIN GCC SETOPTION ######




源代码 - 预处理 - 编译 - 汇编 - 目标代码 - 链接 - 可执行程序		//结合 链接 步骤对静态库和动态库做理解
GCC识别的常见文件类型（部分）
.a		静态库文件
.i		预处理过的C源代码文件
.ii		预处理过的C++源代码文件
.o		编译后的目标文件
.s		汇编语言源代码文件

GCC参数常用值（部分）
-c		只编译生成以 .o 为后缀名的动态加载函数库文件
-S		只编译生成以 .s 为后缀名的汇编代码			gcc -S hello.c -o hello.s
-E		只进行预编译，不做其他处理，可生成 .i 为后缀名的文件	gcc -E hello.c -o hello.i
-o		指定生成文件的名字
-g		生成可执行文件时加上调试工具所必需的符号信息，当需要执行gdb调试时使用
-v		打印编译器内部编译各过程的命令行信息和编译器的版本号
-I dir	在头文件的搜索路径列表中添加dir目录
-L dir	在库文件的搜索路径列表中添加dir目录
-static	链接静态库
-library链接名为library的静态库
-O		编译、链接过程中执行优化处理 -O2 -O3	这些选项不能与-g选项联合使用
-w		禁止提示警告信息
-Wall	开启所有警告信息，在发生警告时取消编译操作，即将警告看作是错误
-Werror	在发生警告时取消编译操作，即将警告看作是错误，常与自动编译工具make一起使用
-pedantic	严格要求符合ANSI标准

借助Linux提供的time命令，可以大致统计出该程序在运行时所需要的时间，注意此时最好退出其他程序。
Linux的time命令用于测量指定程序的执行时间，其结果由以下三部分组成：
	real:进程总的执行时间，它和系统负载有关（包括进程高度、切换的时间）。
	user:被测量的进程中用户指令的执行时间。
	sys:被测量进程中内核代用户指令执行的时间。user和sys的和称为CPU时间。
	
-I	选项可以向gcc的头文件搜索路径中添加新的目录
	gcc foo.c -I /home/lb/include -o foo
-L	选项可以向gcc的库文件搜索路径中添加新的目录
	gcc foo.c -L /home/lb/lib -lfoo -o foo
	在上面的编译命令中，需要说明的是-l选项，它指示gcc去链接库文件libfoo.so。
Linux下的库文件分为两大类，分别是动态链接库（.so）和静态链接库（.a）。默认情况下，gcc在链接时优先使用动态链接库，只有当动态库不存在时才使用
静态库。也可以在编译时加上-static选项，强制使用静态库。
	gcc foo.c -L /home/lb/lib -static -lfoo -o foo

虽然很多动态库或静态库文件处于系统搜索库路径下（/usr/lib或/lib），但毕竟这些路径中包含着许多库，所以在编译时还是需要指定一下具体动态库的
比如系统数学库 libm.so ，去掉前缀 lib 和后缀 .so ，剩下的 m 即为该库文件的名字
	
调试选项
可以通过在-g选项后附加数字1、2或3来指定在代码中加调试信息的多少，默认是2（-g2）。
g2	包括扩展的符号表、行号、局部或外部变量信息。
g3	包含级别2中的所有调试信息，以及源代码中定义的宏。
g1	不包含局部变量和行号有关的调试信息，因此只能用于回溯跟踪和堆栈转储之用。
回溯跟踪：监视程序在运行过程中的函数调用历史
堆栈转储：一种以原始的十六进制格式保存程序执行环境的方法
	
多文件编译（两种方法）
	1.多个文件分别编译成动态加载函数库文件，然后再将所有的动态加载函数库文件链接成一个可执行文件
		gcc -c -g add.o main.o
		gcc add.o main.o -o main -l m
	2.将多个文件直接编译成一个可执行程序
	

	gcc pow.c -l m

GCC给出的错误信息主要分为四大类，分别是：
	错误类型			提示关键字		
	语法错误			error: expected expression before 'xx' token
	缺少头文件			error: 'xx' undeclared(first use in this function)
	缺少库文件			:undefined referenced to 'xx'
	变量未定义			error: 'xx' undeclared(first use in this function)
	
错误的解决方法
gcc给出的错误信息一般可以分为4种：
	1）未定义的符号
	错误信息：有未定义的符号。这类错误是在连接过程中出现的，可能有两种原因：一是用户自己定义的函数
	或者全局变量所在源代码文件，没有被编译、链接，或者还没有定义，这需要根据实际情况修改源程序，给
	出全局变量或函数的定义体。二是未定义的符号是一个标准的库函数，在源程序中使用了该库函数，而连接
	过程中还没有给定相应的函数库的名称，或者是该档案库的目录名称有问题，这时需要使用档案库维护命令
	ar检查需要的库函数位于哪一个函数库中，确定后，修改gcc连接选项中的-l和－L项。
	2）C语法错误
	错误信息：文件source.c中第n行有语法错误。这种类型的错误，一般都是C语言的语法错误，应该仔细检查
	源代码文件中第n行及该行前的程序，有时也需要对该文件所包含的头文件进行检查。
	3）档案库错误
	错误信息：连接程序找不到所需的函数库。这类错误是与目标文件相连接的函数库错误，可能的原因是函数
	库名错误、指定的函数库所在目录名称错误等。检查的方法是使用find命令在可能的目录中寻找相应的函数
	库名，确定档案库及目录的名称并修改程序中及编译选项的名称。
	4）头文件错误
	错误信息：找不到头文件head.h。这类错误是源代码文件中包含的头文件有问题，可能的原因有头文件错误
	、指定的头文件所在目录名错误等，也可能是错误地使用了双引号和尖括号。
